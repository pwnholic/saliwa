---
phase: 02-bybit-infrastructure
plan: 05
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
  - "02-03"
files_modified:
  - internal/driver/bybit/ws_client.go
autonomous: true

must_haves:
  truths:
    - "WebSocket client connects to Bybit streams"
    - "JSON-based heartbeat (ping/pong) keeps connection alive"
    - "Dynamic subscribe/unsubscribe works without reconnection"
    - "Automatic reconnection with exponential backoff"
    - "Messages route to correct callbacks based on topic"
  artifacts:
    - path: "internal/driver/bybit/ws_client.go"
      provides: "WebSocket client with reconnection"
      exports: ["NewWSClient", "WSClient", "WSConfig", "WSClientCallbacks"]
      min_lines: 500
  key_links:
    - from: "WSClient.Subscribe"
      to: "WSSubscription"
      via: "JSON message"
      pattern: '{"op":"subscribe","args":[...]}'
    - from: "WSClient.OnMessage"
      to: "WSMessage types"
      via: "topic routing"
      pattern: "ParseTopicType"
---

<objective>
Create WebSocket client with JSON heartbeat and dynamic subscriptions.

Purpose: Enable real-time market data streaming from Bybit with connection management.
Output: ws_client.go implementing gws.EventHandler with Bybit-specific patterns.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-bybit-infrastructure/02-RESEARCH.md
@.planning/phases/02-bybit-infrastructure/02-CONTEXT.md

# Dependencies from Wave 1
@.planning/phases/02-bybit-infrastructure/02-01-SUMMARY.md
@.planning/phases/02-bybit-infrastructure/02-02-SUMMARY.md
@.planning/phases/02-bybit-infrastructure/02-03-SUMMARY.md

# Reference implementation from Phase 1
@internal/driver/binance/ws_client.go

# Key differences from Binance:
# - JSON heartbeat: {"op":"ping"} / {"op":"pong"} (NOT WebSocket protocol level)
# - Dynamic subscribe IS supported (no reconnection needed for new subs)
# - Topics are UPPERCASE
# - Single WebSocket URL (no combined stream URL format)
</context>

<tasks>

<task type="auto">
  <name>Create Bybit WebSocket client</name>
  <files>internal/driver/bybit/ws_client.go</files>
  <action>
    Create internal/driver/bybit/ws_client.go adapting Binance pattern with Bybit-specific changes.

    Constants:
    - exchange = "bybit"

    WSConfig struct:
    - BaseURL string (default: wss://stream.bybit.com/v5/public/spot)
    - Testnet bool
    - PingInterval time.Duration (default: 20s)
    - Reconnect ReconnectConfig

    WSClientCallbacks struct (same as Binance):
    - OnTicker, OnOrderBook, OnTrade, OnKline, OnOrder
    - OnConnect, OnDisconnect

    WSClient struct:
    - config WSConfig
    - testnet bool
    - callbacks WSClientCallbacks
    - subscriptions *SubscriptionManager
    - conn *gws.Conn
    - connected, connecting, closed atomic.Bool
    - connMu sync.RWMutex
    - reconnectAttempt int
    - ctx, cancel for cancellation
    - pingTicker *time.Ticker

    Key differences from Binance:

    1. Subscribe(topic string) error:
       - Use WSSubscription message: {"op":"subscribe","args":[topic]}
       - Send via WebSocket (NO reconnection needed)
       - Track in subscription manager
       - If not connected, just track (will subscribe on connect)

    2. Unsubscribe(topic string) error:
       - Send {"op":"unsubscribe","args":[topic]}
       - Remove from subscription manager

    3. Heartbeat (CRITICAL - JSON based, not WebSocket protocol):
       - Send {"op":"ping"} via WriteMessage
       - Expect {"op":"pong"} response
       - NOT conn.WritePing() - use JSON message

    4. OnMessage routing:
       - Parse WSMessage with Topic, Type, TS, Data
       - Use ParseTopicType(topic) to determine handler
       - Route to handleTicker, handleOrderbook, handleTrade, etc.

    5. Connect():
       - Build URL with initial topics (optional)
       - Dial WebSocket
       - Start read loop
       - Start ping ticker (JSON-based)

    6. Reconnection:
       - Same exponential backoff with jitter as Binance
       - Resubscribe to all tracked topics after reconnect
       - Use dynamic subscribe for resubscription

    Implement gws.EventHandler:
    - OnOpen(socket *gws.Conn)
    - OnClose(socket *gws.Conn, err error)
    - OnPing/OnPong (standard WebSocket, keepalive)
    - OnMessage(socket *gws.Conn, message *gws.Message)

    Message handlers:
    - handleTicker(data []byte) - parse WSTicker, call OnTicker
    - handleOrderbook(data []byte) - parse WSOrderbookData, call OnOrderBook
    - handleTrade(data []byte) - parse WSTradeData, call OnTrade
    - handlePong(data []byte) - handle heartbeat response

    Add comprehensive documentation comments referencing Bybit WebSocket documentation.
  </action>
  <verify>go build ./internal/driver/bybit/... && go vet ./internal/driver/bybit/...</verify>
  <done>ws_client.go exists with JSON heartbeat, dynamic subscribe, and reconnection</done>
</task>

</tasks>

<verification>
1. WSClient implements gws.EventHandler
2. JSON-based heartbeat works
3. Dynamic subscribe/unsubscribe works
4. Reconnection resubscribes to all topics
5. Message routing based on topic type
</verification>

<success_criteria>
- ws_client.go implements WSClient with all callbacks
- JSON heartbeat (not WebSocket protocol ping)
- Dynamic subscribe without reconnection
- Exponential backoff reconnection
- Message routing to correct handlers
- Code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/02-bybit-infrastructure/02-05-SUMMARY.md`
</output>
