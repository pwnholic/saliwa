---
phase: 02-bybit-infrastructure
plan: 04
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - internal/driver/bybit/rest_client.go
  - internal/driver/bybit/rate_limiter.go
autonomous: true

must_haves:
  truths:
    - "REST client makes authenticated requests to Bybit API"
    - "Per-second rate limiting prevents IP bans"
    - "Bybit error codes map to domain error types"
    - "category=spot parameter is included in all spot requests"
  artifacts:
    - path: "internal/driver/bybit/rest_client.go"
      provides: "REST client with auth and rate limiting"
      exports: ["NewRESTClient", "RESTClient", "Config"]
      min_lines: 350
    - path: "internal/driver/bybit/rate_limiter.go"
      provides: "Per-second rate limiter"
      exports: ["NewPerSecondLimiter", "PerSecondLimiter"]
  key_links:
    - from: "RESTClient.doRequest"
      to: "Signer.Sign"
      via: "authentication headers"
      pattern: "X-BAPI-*"
    - from: "RESTClient.doRequest"
      to: "PerSecondLimiter.Wait"
      via: "rate limiting"
      pattern: "endpoint category"
---

<objective>
Create REST client with authentication, per-second rate limiting, and error mapping.

Purpose: Enable authenticated REST communication with Bybit API using different auth format and rate limiting than Binance.
Output: rest_client.go and rate_limiter.go implementing Bybit-specific patterns.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-bybit-infrastructure/02-RESEARCH.md
@.planning/phases/02-bybit-infrastructure/02-CONTEXT.md

# Dependencies from Wave 1
@.planning/phases/02-bybit-infrastructure/02-01-SUMMARY.md

# Reference implementation from Phase 1
@internal/driver/binance/rest_client.go
@internal/ratelimit/weighted.go

# Key differences from Binance:
# - Authentication: X-BAPI-* headers (not X-MBX-*)
# - Rate limiting: Per-second per-endpoint (not weight-based per-minute)
# - All spot endpoints require category=spot parameter
# - Error codes: 10001, 10004, 10006, etc. (different from Binance)
</context>

<tasks>

<task type="auto">
  <name>Create per-second rate limiter</name>
  <files>internal/driver/bybit/rate_limiter.go</files>
  <action>
    Create internal/driver/bybit/rate_limiter.go implementing per-second rate limiting.

    Unlike Binance's weight-based system, Bybit uses requests per second per endpoint category:
    - Order endpoints: 20 req/s
    - Account endpoints: 10 req/s
    - Query endpoints: 50 req/s

    PerSecondLimiter struct:
    - limiters map[string]*rate.Limiter (one limiter per endpoint category)
    - mu sync.RWMutex

    Categories:
    - "order": 20/s (create, cancel, amend orders)
    - "account": 10/s (balance, positions)
    - "query": 50/s (order status, history)

    Methods:
    - NewPerSecondLimiter() *PerSecondLimiter
    - Wait(ctx context.Context, endpoint string) error
      - Determine category from endpoint
      - Wait for limiter availability
    - SetLimit(category string, limit int)

    Use golang.org/x/time/rate.Limiter with:
    - rate.Limit(limit) for rate
    - burst of 1 (no burst, strict rate limiting)

    Endpoint category mapping:
    - Contains "/order/": "order"
    - Contains "/account/": "account"
    - Default: "query"
  </action>
  <verify>go build ./internal/driver/bybit/... succeeds without errors</verify>
  <done>rate_limiter.go exists with per-second limiting by endpoint category</done>
</task>

<task type="auto">
  <name>Create Bybit REST client with authentication</name>
  <files>internal/driver/bybit/rest_client.go</files>
  <action>
    Create internal/driver/bybit/rest_client.go following Binance pattern with Bybit-specific changes.

    Config struct:
    - BaseURL string (default: production)
    - APIKey string
    - APISecret string
    - Timeout time.Duration (default: 10s)
    - RecvWindow int64 (default: 5000)
    - Testnet bool

    RESTClient struct:
    - client *resty.Client
    - baseURL string
    - signer *Signer
    - rateLimiter *PerSecondLimiter
    - config Config
    - closed bool (atomic or mutex)

    NewRESTClient(cfg Config) (*RESTClient, error):
    - Set defaults for empty fields
    - Create signer if credentials provided
    - Create rate limiter
    - Configure resty client

    Middleware (CRITICAL - different from Binance):
    Request middleware:
    1. Check if closed
    2. Wait for rate limit (PerSecondLimiter.Wait)
    3. Add category=spot parameter for all requests
    4. If authenticated endpoint, sign and add headers:
       - X-BAPI-API-KEY: {apiKey}
       - X-BAPI-TIMESTAMP: {timestamp}
       - X-BAPI-RECV-WINDOW: {recvWindow}
       - X-BAPI-SIGN: {signature}

    Response middleware:
    - Track rate limits from response headers (X-Bapi-Limit-Status)

    Public methods:
    - Close() - REQUIRED by resty v3
    - Ping(ctx context.Context) error - use /v5/market/time
    - GetServerTime(ctx context.Context) (int64, error)
    - SyncTime(ctx context.Context) error - clock synchronization
    - GetExchangeInfo(ctx context.Context) (*ExchangeInfo, error)
    - GetAccount(ctx context.Context) (*AccountInfo, error) - requires auth

    Error handling:
    - Map Bybit error codes to domain errors:
      - 10001 -> ValidationError
      - 10004 -> ExchangeError (sign error)
      - 10006 -> RateLimitError
      - Others -> ExchangeError with original code

    Response types:
    - APIResponse (base): RetCode, RetMsg, Result, Time
    - ExchangeInfo, AccountInfo (similar to Binance but Bybit format)

    Add comprehensive documentation comments.
  </action>
  <verify>go build ./internal/driver/bybit/... && go vet ./internal/driver/bybit/...</verify>
  <done>rest_client.go exists with authentication, rate limiting, and error mapping</done>
</task>

</tasks>

<verification>
1. RESTClient compiles
2. PerSecondLimiter implements per-second limiting
3. Authentication headers are X-BAPI-* format
4. Error codes map correctly
5. category=spot is added to requests
</verification>

<success_criteria>
- rest_client.go implements RESTClient with Config
- rate_limiter.go implements per-second limiting
- Authentication uses X-BAPI-* headers
- Rate limiting is per-second, not weight-based
- Error mapping for Bybit error codes exists
- Code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/02-bybit-infrastructure/02-04-SUMMARY.md`
</output>
