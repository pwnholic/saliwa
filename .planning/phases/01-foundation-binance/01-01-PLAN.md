---
phase: 01-foundation-binance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - pkg/domain/types.go
  - pkg/domain/decimal.go
  - pkg/domain/symbol.go
  - pkg/errors/errors.go
  - pkg/errors/rate_limit.go
  - pkg/errors/connection.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Developer can import domain types without circular dependencies"
    - "All prices and quantities use decimal types (no float64)"
    - "Error types exist for rate limiting, connection, and validation failures"
    - "Domain models are immutable after creation"
    - "go.mod contains all required dependencies"
  artifacts:
    - path: "go.mod"
      provides: "Dependency management"
      contains: "module github.com"
    - path: "pkg/domain/types.go"
      provides: "Core domain types"
      min_lines: 50
      exports: ["Order", "Ticker", "OrderBook", "Trade"]
    - path: "pkg/domain/decimal.go"
      provides: "Decimal arithmetic helpers"
      exports: ["Decimal", "NewDecimal", "MustDecimal", "Zero"]
    - path: "pkg/errors/errors.go"
      provides: "Typed error handling"
      exports: ["RateLimitError", "ConnectionError", "ValidationError"]
  key_links:
    - from: "pkg/domain/types.go"
      to: "cockroachdb/apd"
      via: "import"
      pattern: "apd\\.Decimal"
    - from: "pkg/errors/*.go"
      to: "pkg/errors/errors.go"
      via: "error wrapping"
      pattern: "errors\\.Is|errors\\.As"
---

<objective>
Establish project foundation with proper directory structure, dependencies, and domain models that will be used throughout the codebase.

Purpose: Create immutable, decimal-precise domain models and typed errors that form the contract for all exchange interactions.
Output: go.mod with all dependencies, domain types with apd.Decimal, structured error types
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# AGENTS.md contains critical rules for this project
@AGENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and project structure</name>
  <files>
    go.mod
    go.sum
  </files>
  <action>
Initialize Go 1.25 module at github.com/user/exchange-connector (adjust module path as needed).

Create directory structure following AGENTS.md package organization:
```
pkg/
  connector/     - Public connector API (empty for now)
  domain/        - Public domain models
  config/        - Public configuration (empty for now)
  errors/        - Public error types
  driver/        - Public driver interface (empty for now)

internal/
  app/           - Ergo application (empty for now)
  sup/           - Supervisors (empty for now)
  actor/         - Core actors (empty for now)
  driver/        - Driver implementations
    binance/     - Binance driver (empty for now)
    bybit/       - Bybit driver (empty for now)
    mock/        - Mock driver (empty for now)
  message/       - Internal messages (empty for now)
  event/         - Event definitions (empty for now)
```

Add dependencies to go.mod:
- ergo.services/ergo v3.10 (actor framework)
- github.com/cockroachdb/apd/v3 (decimal precision)
- github.com/lxzan/gws (WebSocket)
- github.com/go-resty/resty/v3 (HTTP client - v3 beta)
- github.com/rs/zerolog (logging)
- golang.org/x/time/rate (rate limiting)
- github.com/sony/gobreaker (circuit breaker)

Run `go mod tidy` to resolve dependencies.

DO NOT add any code files yet - just create directory structure with .gitkeep files where needed.
  </action>
  <verify>
    go mod verify && go build ./...
    
    # Verify directories exist
    test -d pkg/domain && test -d pkg/errors && test -d internal/driver/binance
  </verify>
  <done>
    go.mod exists with all required dependencies, directory structure matches AGENTS.md specification, `go mod tidy` completes without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domain models with decimal precision</name>
  <files>
    pkg/domain/decimal.go
    pkg/domain/types.go
    pkg/domain/symbol.go
  </files>
  <action>
Create pkg/domain/decimal.go with decimal helper functions:

```go
// Package domain provides immutable domain models for exchange operations.
// All financial values use arbitrary-precision decimals to avoid floating-point
// precision loss in financial calculations.

package domain

import (
    "fmt"
    
    "github.com/cockroachdb/apd/v3"
)

// Decimal is an alias for arbitrary-precision decimal numbers.
// Use this for all prices, quantities, and financial calculations.
type Decimal = *apd.Decimal

// NewDecimal creates a Decimal from a string representation.
// Returns error if the string is not a valid decimal.
func NewDecimal(s string) (Decimal, error) {
    d, _, err := apd.NewFromString(s)
    if err != nil {
        return nil, fmt.Errorf("invalid decimal %q: %w", s, err)
    }
    return d, nil
}

// MustDecimal creates a Decimal from a string, panicking on error.
// Use only for compile-time constants.
func MustDecimal(s string) Decimal {
    d, err := NewDecimal(s)
    if err != nil {
        panic(err)
    }
    return d
}

// Zero returns a decimal with value 0.
func Zero() Decimal {
    return apd.New(0, 0)
}

// One returns a decimal with value 1.
func One() Decimal {
    return apd.New(1, 0)
}

// NewDecimalFromInt creates a Decimal from an integer.
func NewDecimalFromInt(n int64) Decimal {
    return apd.New(n, 0)
}

// Add returns a + b.
func Add(a, b Decimal) Decimal {
    result := apd.New(0, 0)
    ctx := apd.BaseContext
    ctx.Add(result, a, b)
    return result
}

// Sub returns a - b.
func Sub(a, b Decimal) Decimal {
    result := apd.New(0, 0)
    ctx := apd.BaseContext
    ctx.Sub(result, a, b)
    return result
}

// Mul returns a * b.
func Mul(a, b Decimal) Decimal {
    result := apd.New(0, 0)
    ctx := apd.BaseContext
    ctx.Mul(result, a, b)
    return result
}

// Div returns a / b.
func Div(a, b Decimal) (Decimal, error) {
    if b.IsZero() {
        return nil, fmt.Errorf("division by zero")
    }
    result := apd.New(0, 0)
    ctx := apd.BaseContext
    _, err := ctx.Div(result, a, b)
    return result, err
}

// Compare returns -1 if a < b, 0 if a == b, 1 if a > b.
func Compare(a, b Decimal) int {
    return a.Cmp(b)
}

// IsPositive returns true if d > 0.
func IsPositive(d Decimal) bool {
    return d.Sign() > 0
}

// IsNegative returns true if d < 0.
func IsNegative(d Decimal) bool {
    return d.Sign() < 0
}

// IsZero returns true if d == 0.
func IsZero(d Decimal) bool {
    return d.IsZero()
}

// String returns the string representation of d.
func String(d Decimal) string {
    return d.String()
}

// Float64 converts d to float64. WARNING: This loses precision.
// Use only for display purposes, never for calculations.
func Float64(d Decimal) (float64, error) {
    f, _, err := d.Float64()
    return f, err
}
```

Create pkg/domain/types.go with core domain types:

```go
package domain

import (
    "time"
)

// OrderSide represents buy or sell.
type OrderSide string

const (
    OrderSideBuy  OrderSide = "BUY"
    OrderSideSell OrderSide = "SELL"
)

// OrderType represents the type of order.
type OrderType string

const (
    OrderTypeLimit  OrderType = "LIMIT"
    OrderTypeMarket OrderType = "MARKET"
)

// OrderStatus represents the current state of an order.
type OrderStatus string

const (
    OrderStatusNew             OrderStatus = "NEW"
    OrderStatusPartiallyFilled OrderStatus = "PARTIALLY_FILLED"
    OrderStatusFilled          OrderStatus = "FILLED"
    OrderStatusCanceled        OrderStatus = "CANCELED"
    OrderStatusPendingCancel   OrderStatus = "PENDING_CANCEL"
    OrderStatusRejected        OrderStatus = "REJECTED"
    OrderStatusExpired         OrderStatus = "EXPIRED"
    OrderStatusCanceling       OrderStatus = "CANCELING" // Internal state for cancel in progress
)

// CanTransition returns true if the order can transition to the new status.
func (s OrderStatus) CanTransition(newStatus OrderStatus) bool {
    validTransitions := map[OrderStatus][]OrderStatus{
        OrderStatusNew: {
            OrderStatusPartiallyFilled,
            OrderStatusFilled,
            OrderStatusCanceled,
            OrderStatusPendingCancel,
            OrderStatusRejected,
            OrderStatusExpired,
        },
        OrderStatusPartiallyFilled: {
            OrderStatusPartiallyFilled,
            OrderStatusFilled,
            OrderStatusCanceled,
            OrderStatusPendingCancel,
        },
        OrderStatusPendingCancel: {
            OrderStatusCanceled,
            OrderStatusPartiallyFilled,
            OrderStatusFilled,
        },
        OrderStatusCanceling: {
            OrderStatusCanceled,
        },
    }
    
    allowed, exists := validTransitions[s]
    if !exists {
        return false // Terminal states cannot transition
    }
    
    for _, status := range allowed {
        if status == newStatus {
            return true
        }
    }
    return false
}

// IsFinal returns true if the order is in a terminal state.
func (s OrderStatus) IsFinal() bool {
    return s == OrderStatusFilled ||
        s == OrderStatusCanceled ||
        s == OrderStatusRejected ||
        s == OrderStatusExpired
}

// Order represents an exchange order.
// All monetary values use Decimal for precision.
type Order struct {
    // Identification
    Exchange       string     // Exchange name (e.g., "binance", "bybit")
    Symbol         string     // Trading pair (e.g., "BTC/USDT")
    OrderID        string     // Exchange-assigned order ID
    ClientOrderID  string     // Client-assigned order ID (optional)
    
    // Order details
    Side           OrderSide  // BUY or SELL
    Type           OrderType  // LIMIT or MARKET
    Status         OrderStatus // Current status
    
    // Quantities (all use Decimal for precision)
    Price          Decimal    // Limit order price
    Quantity       Decimal    // Original order quantity
    ExecutedQty    Decimal    // Quantity filled so far
    RemainingQty   Decimal    // Quantity remaining to fill
    CumulativeQty  Decimal    // Total quantity executed
    AvgPrice       Decimal    // Average execution price
    
    // Fees
    Commission     Decimal    // Total commission paid
    CommissionAsset string    // Asset used for commission
    
    // Timestamps
    CreatedAt      time.Time
    UpdatedAt      time.Time
    
    // Metadata
    TimeInForce    string     // GTC, IOC, FOK
    IsActive       bool       // True if order is still active
}

// OrderRequest contains parameters for placing a new order.
type OrderRequest struct {
    Exchange      string
    Symbol        string
    Side          OrderSide
    Type          OrderType
    Quantity      Decimal
    Price         Decimal    // Required for LIMIT orders
    ClientOrderID string     // Optional client order ID
    TimeInForce   string     // Optional: GTC, IOC, FOK (default: GTC)
}

// CancelRequest contains parameters for canceling an order.
type CancelRequest struct {
    Exchange      string
    Symbol        string
    OrderID       string     // Exchange order ID
    ClientOrderID string     // Alternative: cancel by client order ID
}

// Ticker represents current market price for a symbol.
type Ticker struct {
    Exchange    string
    Symbol      string
    BidPrice    Decimal    // Best bid price
    BidQty      Decimal    // Best bid quantity
    AskPrice    Decimal    // Best ask price
    AskQty      Decimal    // Best ask quantity
    LastPrice   Decimal    // Last trade price
    Volume      Decimal    // 24h volume
    QuoteVolume Decimal    // 24h quote volume
    HighPrice   Decimal    // 24h high
    LowPrice    Decimal    // 24h low
    Timestamp   time.Time
}

// Trade represents a single trade execution.
type Trade struct {
    Exchange   string
    Symbol     string
    TradeID    string
    OrderID    string
    Price      Decimal
    Quantity   Decimal
    QuoteQty   Decimal    // Price * Quantity
    Time       time.Time
    IsBuyer    bool       // True if buyer initiated
    IsMaker    bool       // True if maker order
    Commission Decimal
    CommissionAsset string
}

// OrderBookLevel represents a single price level in the order book.
type OrderBookLevel struct {
    Price    Decimal
    Quantity Decimal
}

// OrderBook represents the current order book state for a symbol.
type OrderBook struct {
    Exchange  string
    Symbol    string
    Bids      []OrderBookLevel // Sorted by price descending
    Asks      []OrderBookLevel // Sorted by price ascending
    Timestamp time.Time
    UpdateID  int64    // Sequence number for continuity validation
}
```

Create pkg/domain/symbol.go with symbol utilities:

```go
package domain

import (
    "fmt"
    "strings"
)

// SymbolInfo contains trading rules and precision for a symbol.
type SymbolInfo struct {
    Exchange       string
    Symbol         string       // Normalized format: "BTC/USDT"
    BaseAsset      string       // "BTC"
    QuoteAsset     string       // "USDT"
    Status         string       // TRADING, HALT, etc.
    
    // Precision
    PricePrecision  int         // Decimal places for price
    QtyPrecision    int         // Decimal places for quantity
    BasePrecision   int         // Decimal places for base asset
    QuotePrecision  int         // Decimal places for quote asset
    
    // Filters
    MinPrice       Decimal      // Minimum price
    MaxPrice       Decimal      // Maximum price
    PriceStep      Decimal      // Price increment (tick size)
    MinQty         Decimal      // Minimum order quantity
    MaxQty         Decimal      // Maximum order quantity
    QtyStep        Decimal      // Quantity increment (step size)
    MinNotional    Decimal      // Minimum order value (price * qty)
}

// NormalizeSymbol converts exchange-specific format to standard format.
// Binance: "BTCUSDT" -> "BTC/USDT"
// Bybit: "BTCUSDT" -> "BTC/USDT"
func NormalizeSymbol(exchangeSymbol string) string {
    // Common quote currencies to split on
    quotes := []string{"USDT", "USDC", "BUSD", "BTC", "ETH", "BNB"}
    
    for _, quote := range quotes {
        if strings.HasSuffix(exchangeSymbol, quote) {
            base := strings.TrimSuffix(exchangeSymbol, quote)
            if base != "" {
                return fmt.Sprintf("%s/%s", base, quote)
            }
        }
    }
    
    // Return as-is if no match
    return exchangeSymbol
}

// ExchangeSymbol converts normalized format to exchange-specific format.
// Standard: "BTC/USDT" -> "BTCUSDT" (Binance/Bybit format)
func ExchangeSymbol(normalizedSymbol string) string {
    return strings.ReplaceAll(normalizedSymbol, "/", "")
}

// ParseSymbol extracts base and quote from normalized symbol.
func ParseSymbol(normalizedSymbol string) (base, quote string, err error) {
    parts := strings.Split(normalizedSymbol, "/")
    if len(parts) != 2 {
        return "", "", fmt.Errorf("invalid symbol format: %s (expected BASE/QUOTE)", normalizedSymbol)
    }
    return parts[0], parts[1], nil
}
```

CRITICAL RULES:
- Use `type Decimal = *apd.Decimal` alias (not struct wrapper) for ergonomics
- All domain types MUST be immutable (return copies, not references)
- OrderStatus MUST have CanTransition and IsFinal methods for state machine validation
- All timestamps MUST use time.Time (not int64)
- Symbol format MUST be normalized to "BASE/QUOTE" internally
  </action>
  <verify>
    go build ./pkg/domain/...
    go vet ./pkg/domain/...
    
    # Verify Decimal type is used (not float64)
    ! grep -r "float64" pkg/domain/types.go || echo "ERROR: float64 found in domain types"
  </verify>
  <done>
    pkg/domain/decimal.go exports Decimal type with arithmetic helpers, pkg/domain/types.go has Order/Ticker/Trade/OrderBook with Decimal fields, pkg/domain/symbol.go has symbol normalization, all files compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create typed error hierarchy</name>
  <files>
    pkg/errors/errors.go
    pkg/errors/rate_limit.go
    pkg/errors/connection.go
  </files>
  <action>
Create pkg/errors/errors.go with base error types:

```go
// Package errors provides typed errors for exchange operations.
// All errors support Go 1.13+ error wrapping with errors.Is and errors.As.

package errors

import (
    "fmt"
    "time"
)

// ExchangeError is the base type for all exchange-related errors.
type ExchangeError struct {
    Exchange string   // Exchange where error occurred
    Message  string   // Human-readable message
    Cause    error    // Underlying error (for wrapping)
}

func (e *ExchangeError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%s] %s: %v", e.Exchange, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%s] %s", e.Exchange, e.Message)
}

func (e *ExchangeError) Unwrap() error {
    return e.Cause
}

// NewExchangeError creates a new ExchangeError.
func NewExchangeError(exchange, message string, cause error) *ExchangeError {
    return &ExchangeError{
        Exchange: exchange,
        Message:  message,
        Cause:    cause,
    }
}

// ValidationError indicates invalid input parameters.
type ValidationError struct {
    Field    string      // Field that failed validation
    Value    interface{} // Value that was invalid
    Message  string      // Validation message
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error: %s=%v - %s", e.Field, e.Value, e.Message)
}

// NewValidationError creates a new ValidationError.
func NewValidationError(field string, value interface{}, message string) *ValidationError {
    return &ValidationError{
        Field:   field,
        Value:   value,
        Message: message,
    }
}

// NotFoundError indicates a resource was not found.
type NotFoundError struct {
    Resource string // Type of resource
    ID       string // Resource identifier
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s not found: %s", e.Resource, e.ID)
}

// NewNotFoundError creates a new NotFoundError.
func NewNotFoundError(resource, id string) *NotFoundError {
    return &NotFoundError{
        Resource: resource,
        ID:       id,
    }
}

// IsRetryable returns true if the error is transient and the operation can be retried.
func IsRetryable(err error) bool {
    // Rate limit errors are retryable after waiting
    var rateLimitErr *RateLimitError
    if As(err, &rateLimitErr) {
        return true
    }
    
    // Connection errors are retryable
    var connErr *ConnectionError
    if As(err, &connErr) {
        return connErr.Retryable
    }
    
    return false
}

// Import errors package functions for convenience
import "errors"

// Is is an alias for errors.Is
var Is = errors.Is

// As is an alias for errors.As
var As = errors.As
```

Create pkg/errors/rate_limit.go for rate limiting errors:

```go
package errors

import (
    "fmt"
    "time"
)

// RateLimitError indicates a rate limit was exceeded.
type RateLimitError struct {
    Exchange   string        // Exchange that rate limited
    RetryAfter time.Duration // How long to wait before retry
    Weight     int           // Weight of the request that was limited
    Message    string        // Additional context
}

func (e *RateLimitError) Error() string {
    return fmt.Sprintf("[%s] rate limit exceeded (weight=%d): retry after %v - %s",
        e.Exchange, e.Weight, e.RetryAfter, e.Message)
}

// NewRateLimitError creates a new RateLimitError.
func NewRateLimitError(exchange string, retryAfter time.Duration, weight int, message string) *RateLimitError {
    return &RateLimitError{
        Exchange:   exchange,
        RetryAfter: retryAfter,
        Weight:     weight,
        Message:    message,
    }
}

// IsRetryable always returns true for rate limit errors.
func (e *RateLimitError) IsRetryable() bool {
    return true
}

// IPBanError indicates the IP has been banned by the exchange.
type IPBanError struct {
    Exchange   string
    RetryAfter time.Duration
    Reason     string
}

func (e *IPBanError) Error() string {
    return fmt.Sprintf("[%s] IP banned: %s (retry after %v)",
        e.Exchange, e.Reason, e.RetryAfter)
}

// NewIPBanError creates a new IPBanError.
func NewIPBanError(exchange string, retryAfter time.Duration, reason string) *IPBanError {
    return &IPBanError{
        Exchange:   exchange,
        RetryAfter: retryAfter,
        Reason:     reason,
    }
}
```

Create pkg/errors/connection.go for connection errors:

```go
package errors

import (
    "fmt"
    "time"
)

// ConnectionError indicates a connection-related failure.
type ConnectionError struct {
    Exchange  string        // Exchange where connection failed
    Type      string        // "rest" or "websocket"
    Message   string        // Error details
    Retryable bool          // Whether the connection can be retried
    Cause     error         // Underlying error
}

func (e *ConnectionError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%s] %s connection error: %s - %v",
            e.Exchange, e.Type, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%s] %s connection error: %s",
        e.Exchange, e.Type, e.Message)
}

func (e *ConnectionError) Unwrap() error {
    return e.Cause
}

// NewConnectionError creates a new ConnectionError.
func NewConnectionError(exchange, connType, message string, retryable bool, cause error) *ConnectionError {
    return &ConnectionError{
        Exchange:  exchange,
        Type:      connType,
        Message:   message,
        Retryable: retryable,
        Cause:     cause,
    }
}

// WebSocketReconnectError indicates WebSocket reconnection failed.
type WebSocketReconnectError struct {
    Exchange  string
    Attempt   int
    MaxAttempts int
    LastError error
    NextDelay time.Duration
}

func (e *WebSocketReconnectError) Error() string {
    return fmt.Sprintf("[%s] websocket reconnection failed (attempt %d/%d), next retry in %v: %v",
        e.Exchange, e.Attempt, e.MaxAttempts, e.NextDelay, e.LastError)
}

func (e *WebSocketReconnectError) Unwrap() error {
    return e.LastError
}

// CircuitBreakerError indicates the circuit breaker is open.
type CircuitBreakerError struct {
    Exchange   string
    State      string        // "open" or "half-open"
    ResetAfter time.Duration // Time until reset attempt
}

func (e *CircuitBreakerError) Error() string {
    return fmt.Sprintf("[%s] circuit breaker %s (reset in %v)",
        e.Exchange, e.State, e.ResetAfter)
}

// NewCircuitBreakerError creates a new CircuitBreakerError.
func NewCircuitBreakerError(exchange, state string, resetAfter time.Duration) *CircuitBreakerError {
    return &CircuitBreakerError{
        Exchange:   exchange,
        State:      state,
        ResetAfter: resetAfter,
    }
}

// ClockSyncError indicates clock synchronization failure.
type ClockSyncError struct {
    Exchange string
    Offset   time.Duration // Current offset from server time
    Max      time.Duration // Maximum allowed offset
}

func (e *ClockSyncError) Error() string {
    return fmt.Sprintf("[%s] clock sync error: offset %v exceeds maximum %v",
        e.Exchange, e.Offset, e.Max)
}

// NewClockSyncError creates a new ClockSyncError.
func NewClockSyncError(exchange string, offset, max time.Duration) *ClockSyncError {
    return &ClockSyncError{
        Exchange: exchange,
        Offset:   offset,
        Max:      max,
    }
}

// SignatureError indicates request signing failed.
type SignatureError struct {
    Exchange string
    Message  string
    Cause    error
}

func (e *SignatureError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%s] signature error: %s - %v", e.Exchange, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%s] signature error: %s", e.Exchange, e.Message)
}

func (e *SignatureError) Unwrap() error {
    return e.Cause
}

// NewSignatureError creates a new SignatureError.
func NewSignatureError(exchange, message string, cause error) *SignatureError {
    return &SignatureError{
        Exchange: exchange,
        Message:  message,
        Cause:    cause,
    }
}
```

CRITICAL RULES:
- All errors MUST implement Error() string
- Wrappable errors MUST implement Unwrap() error
- All errors MUST be checkable with errors.Is and errors.As
- IsRetryable() function MUST exist for recovery decisions
  </action>
  <verify>
    go build ./pkg/errors/...
    go vet ./pkg/errors/...
    
    # Verify error types implement error interface
    go test -run "^$" ./pkg/errors/... 2>&1 | grep -v "no test files" || true
  </verify>
  <done>
    pkg/errors has ExchangeError, ValidationError, RateLimitError, ConnectionError, CircuitBreakerError, ClockSyncError, SignatureError types, all support error wrapping, IsRetryable function exists
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all dependencies resolve:
   ```bash
   go mod verify
   go build ./...
   ```

2. Verify no float64 in domain types:
   ```bash
   ! grep -r "float64" pkg/domain/types.go
   ```

3. Verify error types are wrappable:
   ```bash
   grep -r "Unwrap()" pkg/errors/
   ```
</verification>

<success_criteria>
- go.mod exists with all required dependencies
- Directory structure matches AGENTS.md specification
- pkg/domain exports Decimal type with arithmetic helpers
- pkg/domain/types.go has Order/Ticker/Trade/OrderBook with Decimal fields
- pkg/domain/symbol.go has symbol normalization
- pkg/errors has typed errors supporting Go 1.13+ wrapping
- All code compiles without errors
- `go mod tidy` completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-binance/01-01-SUMMARY.md`
</output>
