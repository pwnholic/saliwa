---
phase: 01-foundation-binance
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/driver/binance/rest_client.go
  - internal/driver/binance/signer.go
  - internal/driver/binance/urls.go
  - internal/ratelimit/weighted.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Developer can make authenticated REST requests to Binance API"
    - "All requests are signed with HMAC-SHA256"
    - "Weight-based rate limits are automatically tracked and enforced"
    - "X-MBX-USED-WEIGHT headers are parsed and tracked"
    - "recvWindow is included in all signed requests"
  artifacts:
    - path: "internal/driver/binance/rest_client.go"
      provides: "Binance REST API client"
      exports: ["RESTClient", "NewRESTClient"]
      min_lines: 100
    - path: "internal/driver/binance/signer.go"
      provides: "HMAC-SHA256 request signing"
      exports: ["Signer", "NewSigner"]
    - path: "internal/ratelimit/weighted.go"
      provides: "Weight-based rate limiter"
      exports: ["WeightedLimiter", "NewWeightedLimiter"]
  key_links:
    - from: "internal/driver/binance/rest_client.go"
      to: "internal/driver/binance/signer.go"
      via: "Sign() method"
      pattern: "signer\\.Sign"
    - from: "internal/driver/binance/rest_client.go"
      to: "internal/ratelimit/weighted.go"
      via: "middleware"
      pattern: "rateLimiter\\.Wait"
---

<objective>
Implement Binance REST client with HMAC-SHA256 authentication and weight-based rate limiting.

Purpose: Provide authenticated, rate-limited REST communication with Binance API v3.
Output: RESTClient with signing middleware, Signer for HMAC-SHA256, WeightedLimiter for weight tracking
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AGENTS.md

# Domain models from Plan 01
@pkg/domain/types.go
@pkg/domain/decimal.go
@pkg/errors/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Binance URLs and signer</name>
  <files>
    internal/driver/binance/urls.go
    internal/driver/binance/signer.go
  </files>
  <action>
Create internal/driver/binance/urls.go with Binance API endpoints:

```go
// Package binance implements the Binance exchange driver.
// API Version: v3 (Spot)
// Documentation: https://binance-docs.github.io/apidocs/spot/en/

package binance

const (
    // Production endpoints
    BaseRestURL    = "https://api.binance.com"
    BaseWebSocketURL = "wss://stream.binance.com:9443/ws"
    
    // Testnet endpoints
    TestnetRestURL    = "https://testnet.binance.vision"
    TestnetWebSocketURL = "wss://testnet.binance.vision/ws"
)

// REST API endpoints (v3)
const (
    // General endpoints
    EPing          = "/api/v3/ping"
    ETime          = "/api/v3/time"
    EExchangeInfo  = "/api/v3/exchangeInfo"
    
    // Market data endpoints (public)
    EDepth         = "/api/v3/depth"
    ETrades        = "/api/v3/trades"
    EHistoricalTrades = "/api/v3/historicalTrades"
    EAggTrades     = "/api/v3/aggTrades"
    EKlines        = "/api/v3/klines"
    ETickerPrice   = "/api/v3/ticker/price"
    ETicker24hr    = "/api/v3/ticker/24hr"
    ETickerBook    = "/api/v3/ticker/bookTicker"
    
    // Account endpoints (authenticated)
    ENewOrder      = "/api/v3/order"
    EQueryOrder    = "/api/v3/order"
    ECancelOrder   = "/api/v3/order"
    EOpenOrders    = "/api/v3/openOrders"
    EAllOrders     = "/api/v3/allOrders"
    EAccount       = "/api/v3/account"
    EMyTrades      = "/api/v3/myTrades"
    
    // WebSocket stream names
    WSTicker       = "@ticker"
    WSDepth        = "@depth"
    WSTrade        = "@trade"
    WSAggTrade     = "@aggTrade"
    WSKline        = "@kline"
    WSBookTicker   = "@bookTicker"
    WSUserStream   = "@userData"
)

// Rate limit configuration
const (
    DefaultRecvWindow     = 5000  // milliseconds
    MaxRecvWindow         = 60000 // milliseconds
    DefaultRequestWeight  = 1200  // requests per minute (weight-based)
)
```

Create internal/driver/binance/signer.go with HMAC-SHA256 signing:

```go
package binance

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "net/url"
    "strconv"
    "time"
    
    "github.com/user/exchange-connector/pkg/errors"
)

// Signer handles HMAC-SHA256 signature generation for Binance API.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#signed-trade-and-user_data-endpoint-security
type Signer struct {
    apiKey    string
    apiSecret string
    recvWindow int64
}

// NewSigner creates a new Signer for Binance authentication.
func NewSigner(apiKey, apiSecret string, recvWindow int64) *Signer {
    if recvWindow <= 0 {
        recvWindow = DefaultRecvWindow
    }
    if recvWindow > MaxRecvWindow {
        recvWindow = MaxRecvWindow
    }
    return &Signer{
        apiKey:     apiKey,
        apiSecret:  apiSecret,
        recvWindow: recvWindow,
    }
}

// APIKey returns the API key for request headers.
func (s *Signer) APIKey() string {
    return s.apiKey
}

// Sign generates HMAC-SHA256 signature for the given parameters.
// The signature is computed over the query string (sorted alphabetically).
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#signed-trade-and-user_data-endpoint-security
func (s *Signer) Sign(params url.Values) (timestamp int64, signature string) {
    // Add timestamp for replay protection
    timestamp = time.Now().UnixMilli()
    params.Set("timestamp", strconv.FormatInt(timestamp, 10))
    
    // Add recvWindow
    if s.recvWindow > 0 {
        params.Set("recvWindow", strconv.FormatInt(s.recvWindow, 10))
    }
    
    // Generate signature over query string
    queryString := params.Encode()
    mac := hmac.New(sha256.New, []byte(s.apiSecret))
    mac.Write([]byte(queryString))
    signature = hex.EncodeToString(mac.Sum(nil))
    
    return timestamp, signature
}

// SignString generates signature for a raw query string.
func (s *Signer) SignString(queryString string) string {
    mac := hmac.New(sha256.New, []byte(s.apiSecret))
    mac.Write([]byte(queryString))
    return hex.EncodeToString(mac.Sum(nil))
}

// AddAuth adds authentication headers to the request.
func (s *Signer) AddAuth(headers map[string]string) {
    headers["X-MBX-APIKEY"] = s.apiKey
}

// ValidateCredentials checks if the signer has valid credentials.
func (s *Signer) ValidateCredentials() error {
    if s.apiKey == "" {
        return errors.NewValidationError("apiKey", "", "must not be empty")
    }
    if s.apiSecret == "" {
        return errors.NewValidationError("apiSecret", "", "must not be empty")
    }
    return nil
}
```

CRITICAL RULES:
- Signature MUST be computed over sorted query string
- Timestamp MUST be in milliseconds (UnixMilli)
- recvWindow MUST default to 5000ms, max 60000ms
- API key MUST be sent in X-MBX-APIKEY header (not in query params)
- NEVER log apiSecret
</action>
  <verify>
    go build ./internal/driver/binance/...
    go vet ./internal/driver/binance/...
  </verify>
  <done>
    internal/driver/binance/urls.go defines all Binance v3 endpoints, signer.go implements HMAC-SHA256 signing with timestamp and recvWindow
  </done>
</task>

<task type="auto">
  <name>Task 2: Create weighted rate limiter</name>
  <files>
    internal/ratelimit/weighted.go
  </files>
  <action>
Create internal/ratelimit/weighted.go with weight-based rate limiting:

```go
// Package ratelimit implements rate limiting strategies for exchanges.
// Binance uses weight-based rate limiting (not request count).

package ratelimit

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
)

// WeightedLimiter implements weight-based rate limiting for Binance.
// Each API endpoint has a "weight" that counts against the rate limit.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#limits
type WeightedLimiter struct {
    // Configuration
    maxWeight    int           // Maximum weight per minute
    burstWeight  int           // Burst capacity
    
    // State
    currentWeight atomic.Int64 // Current used weight (from X-MBX-USED-WEIGHT header)
    limiter       *rate.Limiter // Token bucket for request timing
    
    // Tracking
    mutex         sync.RWMutex
    lastUpdate    time.Time
    
    // Metrics
    totalRequests atomic.Int64
    totalWeight   atomic.Int64
    rejectedCount atomic.Int64
}

// NewWeightedLimiter creates a new weight-based rate limiter.
// maxWeight is the maximum weight allowed per minute (default 1200 for Binance).
func NewWeightedLimiter(maxWeight int) *WeightedLimiter {
    if maxWeight <= 0 {
        maxWeight = 1200 // Binance default
    }
    
    // Convert weight-per-minute to weight-per-second for limiter
    weightPerSecond := float64(maxWeight) / 60.0
    
    return &WeightedLimiter{
        maxWeight:   maxWeight,
        burstWeight: maxWeight / 10, // Allow 10% burst
        limiter:     rate.NewLimiter(rate.Limit(weightPerSecond), maxWeight/10),
    }
}

// Wait blocks until the requested weight is available or context is cancelled.
// Returns error if context is cancelled before weight is available.
func (wl *WeightedLimiter) Wait(ctx context.Context, weight int) error {
    if weight <= 0 {
        weight = 1 // Default weight
    }
    
    // Check if we would exceed current weight
    if int(wl.currentWeight.Load())+weight > wl.maxWeight {
        wl.rejectedCount.Add(1)
        return fmt.Errorf("rate limit exceeded: current weight %d + requested %d > max %d",
            wl.currentWeight.Load(), weight, wl.maxWeight)
    }
    
    // Wait for rate limiter to allow the request
    // Use separate reservation for each weight unit
    for i := 0; i < weight; i++ {
        if err := wl.limiter.Wait(ctx); err != nil {
            return fmt.Errorf("rate limit wait cancelled: %w", err)
        }
    }
    
    wl.totalRequests.Add(1)
    wl.totalWeight.Add(int64(weight))
    
    return nil
}

// Allow checks if the requested weight is available without blocking.
func (wl *WeightedLimiter) Allow(weight int) bool {
    if weight <= 0 {
        weight = 1
    }
    
    if int(wl.currentWeight.Load())+weight > wl.maxWeight {
        return false
    }
    
    return wl.limiter.AllowN(time.Now(), weight)
}

// UpdateWeight updates the current weight from exchange response headers.
// Call this with the X-MBX-USED-WEIGHT-* header value.
func (wl *WeightedLimiter) UpdateWeight(weight int) {
    wl.mutex.Lock()
    defer wl.mutex.Unlock()
    
    wl.currentWeight.Store(int64(weight))
    wl.lastUpdate = time.Now()
}

// CurrentWeight returns the current used weight.
func (wl *WeightedLimiter) CurrentWeight() int {
    return int(wl.currentWeight.Load())
}

// MaxWeight returns the maximum allowed weight.
func (wl *WeightedLimiter) MaxWeight() int {
    return wl.maxWeight
}

// WaitTime returns the estimated wait time for the given weight.
func (wl *WeightedLimiter) WaitTime(weight int) time.Duration {
    if weight <= 0 {
        weight = 1
    }
    
    reservation := wl.limiter.ReserveN(time.Now(), weight)
    if !reservation.OK() {
        return time.Duration(-1) // Cannot satisfy
    }
    defer reservation.Cancel()
    
    return reservation.Delay()
}

// Stats returns rate limiter statistics.
func (wl *WeightedLimiter) Stats() LimiterStats {
    return LimiterStats{
        TotalRequests: wl.totalRequests.Load(),
        TotalWeight:   wl.totalWeight.Load(),
        CurrentWeight: wl.currentWeight.Load(),
        MaxWeight:     int64(wl.maxWeight),
        RejectedCount: wl.rejectedCount.Load(),
    }
}

// LimiterStats contains rate limiter statistics.
type LimiterStats struct {
    TotalRequests int64
    TotalWeight   int64
    CurrentWeight int64
    MaxWeight     int64
    RejectedCount int64
}

// Reset resets the rate limiter state.
func (wl *WeightedLimiter) Reset() {
    wl.currentWeight.Store(0)
    wl.totalRequests.Store(0)
    wl.totalWeight.Store(0)
    wl.rejectedCount.Store(0)
    wl.lastUpdate = time.Time{}
}
```

CRITICAL RULES:
- Binance uses WEIGHT-based rate limiting (not request count)
- Weight is tracked via X-MBX-USED-WEIGHT-* response headers
- Default limit is 1200 weight per minute
- Must use golang.org/x/time/rate for smooth rate limiting
- UpdateWeight MUST be called after each request to track actual usage
</action>
  <verify>
    go build ./internal/ratelimit/...
    go vet ./internal/ratelimit/...
  </verify>
  <done>
    internal/ratelimit/weighted.go exports WeightedLimiter with Wait/Allow/UpdateWeight methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Binance REST client with middleware</name>
  <files>
    internal/driver/binance/rest_client.go
  </files>
  <action>
Create internal/driver/binance/rest_client.go with REST client:

```go
package binance

import (
    "context"
    "fmt"
    "net/http"
    "net/url"
    "strconv"
    "strings"
    "time"
    
    "github.com/go-resty/resty/v3"
    "github.com/rs/zerolog/log"
    
    "github.com/user/exchange-connector/pkg/domain"
    "github.com/user/exchange-connector/pkg/errors"
    "github.com/user/exchange-connector/internal/ratelimit"
)

// RESTClient implements Binance REST API v3 client.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/
type RESTClient struct {
    client      *resty.Client
    baseURL     string
    signer      *Signer
    rateLimiter *ratelimit.WeightedLimiter
    
    // Configuration
    timeout     time.Duration
    
    // State
    serverTime  atomic.Int64
}

// Config contains REST client configuration.
type Config struct {
    BaseURL      string        // API base URL (production or testnet)
    APIKey       string        // API key for authentication
    APISecret    string        // API secret for signing
    Timeout      time.Duration // Request timeout
    MaxWeight    int           // Maximum weight per minute
    RecvWindow   int64         // Timestamp recvWindow in ms
    Testnet      bool          // Use testnet endpoints
}

// NewRESTClient creates a new Binance REST client.
func NewRESTClient(cfg Config) (*RESTClient, error) {
    // Set defaults
    if cfg.Timeout == 0 {
        cfg.Timeout = 10 * time.Second
    }
    if cfg.MaxWeight == 0 {
        cfg.MaxWeight = 1200
    }
    if cfg.RecvWindow == 0 {
        cfg.RecvWindow = DefaultRecvWindow
    }
    
    // Determine base URL
    baseURL := cfg.BaseURL
    if baseURL == "" {
        if cfg.Testnet {
            baseURL = TestnetRestURL
        } else {
            baseURL = BaseRestURL
        }
    }
    
    // Create signer if credentials provided
    var signer *Signer
    if cfg.APIKey != "" && cfg.APISecret != "" {
        signer = NewSigner(cfg.APIKey, cfg.APISecret, cfg.RecvWindow)
        if err := signer.ValidateCredentials(); err != nil {
            return nil, err
        }
    }
    
    // Create resty client
    // NOTE: resty v3 requires defer client.Close()
    client := resty.New()
    client.SetBaseURL(baseURL)
    client.SetTimeout(cfg.Timeout)
    client.SetRetryCount(3)
    client.SetRetryWaitTime(1 * time.Second)
    client.SetRetryMaxWaitTime(5 * time.Second)
    
    // Retry on 5xx errors and network errors
    client.AddRetryCondition(func(r *resty.Response, err error) bool {
        return err != nil || r.StatusCode() >= 500
    })
    
    rc := &RESTClient{
        client:      client,
        baseURL:     baseURL,
        signer:      signer,
        rateLimiter: ratelimit.NewWeightedLimiter(cfg.MaxWeight),
        timeout:     cfg.Timeout,
    }
    
    // Add middleware for rate limiting and weight tracking
    rc.setupMiddleware()
    
    return rc, nil
}

// setupMiddleware configures request/response middleware.
func (rc *RESTClient) setupMiddleware() {
    // Before request: rate limiting
    rc.client.OnBeforeRequest(func(c *resty.Client, req *resty.Request) error {
        weight := rc.getEndpointWeight(req.URL)
        
        // Wait for rate limiter
        ctx := req.Context()
        if ctx == nil {
            ctx = context.Background()
        }
        
        if err := rc.rateLimiter.Wait(ctx, weight); err != nil {
            return errors.NewRateLimitError("binance", rc.rateLimiter.WaitTime(weight), weight, err.Error())
        }
        
        return nil
    })
    
    // After response: track weight, handle errors
    rc.client.OnAfterResponse(func(c *resty.Client, resp *resty.Response) error {
        // Track weight from response headers
        if weightStr := resp.Header().Get("X-MBX-USED-WEIGHT-1M"); weightStr != "" {
            if weight, err := strconv.Atoi(weightStr); err == nil {
                rc.rateLimiter.UpdateWeight(weight)
            }
        }
        
        // Update server time
        if serverTimeStr := resp.Header().Get("X-MBX-RECV-WINDOW"); serverTimeStr != "" {
            if serverTime, err := strconv.ParseInt(serverTimeStr, 10, 64); err == nil {
                rc.serverTime.Store(serverTime)
            }
        }
        
        // Handle error responses
        if resp.IsError() {
            return rc.handleErrorResponse(resp)
        }
        
        return nil
    })
}

// getEndpointWeight returns the weight for an endpoint.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#limits
func (rc *RESTClient) getEndpointWeight(endpoint string) int {
    // Common weights (check API docs for complete list)
    weights := map[string]int{
        EPing:         1,
        ETime:         1,
        EExchangeInfo: 20,
        EDepth:        2,   // Can be higher with limit parameter
        ETrades:       2,
        ETickerPrice:  2,   // Can be higher with symbols parameter
        ETicker24hr:   2,   // Can be higher with symbols parameter
        ENewOrder:     1,
        EQueryOrder:   2,
        ECancelOrder:  1,
        EOpenOrders:   3,   // Can be higher with symbol parameter
        EAccount:      10,
        EMyTrades:     2,
    }
    
    // Extract endpoint path
    for ep, weight := range weights {
        if strings.Contains(endpoint, ep) {
            return weight
        }
    }
    
    return 1 // Default weight
}

// handleErrorResponse converts HTTP error responses to typed errors.
func (rc *RESTClient) handleErrorResponse(resp *resty.Response) error {
    body := string(resp.Body())
    
    switch resp.StatusCode() {
    case http.StatusBadRequest:
        return errors.NewValidationError("request", body, "bad request")
    case http.StatusUnauthorized:
        return errors.NewSignatureError("binance", "unauthorized", nil)
    case http.StatusForbidden:
        return errors.NewSignatureError("binance", "forbidden", nil)
    case http.StatusTooManyRequests:
        return errors.NewRateLimitError("binance", 1*time.Minute, 0, body)
    case http.StatusIAmATeapot: // 418 - IP banned
        return errors.NewIPBanError("binance", 1*time.Hour, body)
    case http.StatusInternalServerError, http.StatusBadGateway, http.StatusServiceUnavailable:
        return errors.NewConnectionError("binance", "rest", "server error", true, fmt.Errorf("%s", body))
    default:
        return errors.NewExchangeError("binance", body, nil)
    }
}

// Close releases resources.
// IMPORTANT: Must be called when done (resty v3 requirement).
func (rc *RESTClient) Close() {
    rc.client.Close()
}

// Ping tests connectivity to the REST API.
// API: GET /api/v3/ping
// Weight: 1
func (rc *RESTClient) Ping(ctx context.Context) error {
    _, err := rc.client.R().
        SetContext(ctx).
        Get(EPing)
    return err
}

// GetServerTime retrieves the exchange server time.
// API: GET /api/v3/time
// Weight: 1
func (rc *RESTClient) GetServerTime(ctx context.Context) (int64, error) {
    var result struct {
        ServerTime int64 `json:"serverTime"`
    }
    
    _, err := rc.client.R().
        SetContext(ctx).
        SetResult(&result).
        Get(ETime)
    
    if err != nil {
        return 0, err
    }
    
    rc.serverTime.Store(result.ServerTime)
    return result.ServerTime, nil
}

// GetExchangeInfo retrieves exchange trading rules and symbol information.
// API: GET /api/v3/exchangeInfo
// Weight: 20
func (rc *RESTClient) GetExchangeInfo(ctx context.Context) (*ExchangeInfo, error) {
    var result ExchangeInfo
    
    _, err := rc.client.R().
        SetContext(ctx).
        SetResult(&result).
        Get(EExchangeInfo)
    
    if err != nil {
        return nil, err
    }
    
    return &result, nil
}

// ExchangeInfo represents Binance exchange information.
type ExchangeInfo struct {
    Timezone        string        `json:"timezone"`
    ServerTime      int64         `json:"serverTime"`
    RateLimits      []RateLimit   `json:"rateLimits"`
    ExchangeFilters []interface{} `json:"exchangeFilters"`
    Symbols         []SymbolInfo  `json:"symbols"`
}

// RateLimit represents a Binance rate limit.
type RateLimit struct {
    RateLimitType string `json:"rateLimitType"`
    Interval      string `json:"interval"`
    IntervalNum   int    `json:"intervalNum"`
    Limit         int    `json:"limit"`
}

// SymbolInfo represents Binance symbol trading rules.
type SymbolInfo struct {
    Symbol                string                   `json:"symbol"`
    Status                string                   `json:"status"`
    BaseAsset             string                   `json:"baseAsset"`
    BaseAssetPrecision    int                      `json:"baseAssetPrecision"`
    QuoteAsset            string                   `json:"quoteAsset"`
    QuotePrecision        int                      `json:"quotePrecision"`
    QuoteAssetPrecision   int                      `json:"quoteAssetPrecision"`
    OrderTypes            []string                 `json:"orderTypes"`
    Filters               []map[string]interface{} `json:"filters"`
}

// doSignedRequest performs an authenticated request.
func (rc *RESTClient) doSignedRequest(ctx context.Context, method, endpoint string, params url.Values, result interface{}) error {
    if rc.signer == nil {
        return errors.NewValidationError("credentials", "", "API key and secret required for authenticated requests")
    }
    
    // Sign the request
    timestamp, signature := rc.signer.Sign(params)
    params.Set("timestamp", strconv.FormatInt(timestamp, 10))
    params.Set("signature", signature)
    
    // Build request
    req := rc.client.R().
        SetContext(ctx).
        SetHeader("X-MBX-APIKEY", rc.signer.APIKey()).
        SetQueryParamsFromValues(params)
    
    if result != nil {
        req.SetResult(result)
    }
    
    // Execute
    var resp *resty.Response
    var err error
    
    switch strings.ToUpper(method) {
    case "GET":
        resp, err = req.Get(endpoint)
    case "POST":
        resp, err = req.Post(endpoint)
    case "DELETE":
        resp, err = req.Delete(endpoint)
    case "PUT":
        resp, err = req.Put(endpoint)
    default:
        return fmt.Errorf("unsupported method: %s", method)
    }
    
    if err != nil {
        return errors.NewConnectionError("binance", "rest", "request failed", true, err)
    }
    
    if resp.IsError() {
        return rc.handleErrorResponse(resp)
    }
    
    return nil
}

// GetServerTimeOffset returns the offset between local and server time.
func (rc *RESTClient) GetServerTimeOffset() time.Duration {
    serverTime := rc.serverTime.Load()
    if serverTime == 0 {
        return 0
    }
    localTime := time.Now().UnixMilli()
    return time.Duration(localTime-serverTime) * time.Millisecond
}

// RateLimiter returns the rate limiter for external access.
func (rc *RESTClient) RateLimiter() *ratelimit.WeightedLimiter {
    return rc.rateLimiter
}
```

CRITICAL RULES:
- resty v3 MUST call Close() when done (breaking change from v2)
- Use context-based timeouts, NOT http.Client.Timeout
- Retry-After header is respected automatically by resty
- X-MBX-USED-WEIGHT-* headers MUST be parsed and tracked
- HMAC signature MUST include timestamp and recvWindow
- API key goes in X-MBX-APIKEY header, NOT in query params
</action>
  <verify>
    go build ./internal/driver/binance/...
    go vet ./internal/driver/binance/...
    
    # Verify resty v3 Close method is present
    grep -n "Close()" internal/driver/binance/rest_client.go
  </verify>
  <done>
    internal/driver/binance/rest_client.go exports RESTClient with Ping/GetServerTime/GetExchangeInfo methods, middleware for rate limiting and weight tracking
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify REST client builds:
   ```bash
   go build ./internal/driver/binance/...
   go vet ./internal/driver/binance/...
   ```

2. Verify rate limiter is separate package:
   ```bash
   go build ./internal/ratelimit/...
   ```

3. Verify no float64 in financial calculations:
   ```bash
   ! grep -r "float64" internal/driver/binance/rest_client.go || echo "WARNING: float64 found"
   ```

4. Verify signer uses HMAC-SHA256:
   ```bash
   grep -n "sha256.New" internal/driver/binance/signer.go
   ```
</verification>

<success_criteria>
- internal/driver/binance/urls.go defines all Binance v3 endpoints
- internal/driver/binance/signer.go implements HMAC-SHA256 signing
- internal/ratelimit/weighted.go exports WeightedLimiter
- internal/driver/binance/rest_client.go exports RESTClient with middleware
- Close() method present (resty v3 requirement)
- X-MBX-USED-WEIGHT tracking in middleware
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-binance/01-02-SUMMARY.md`
</output>
