---
phase: 01-foundation-binance
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/driver/binance/ws_client.go
  - internal/driver/binance/ws_messages.go
  - internal/driver/binance/subscription.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Developer can establish WebSocket connection to Binance streams"
    - "Connections automatically reconnect with exponential backoff on disconnect"
    - "All subscriptions are restored after reconnection"
    - "Ping/pong keeps connection alive (20-second intervals)"
    - "Partial connectivity allowed (REST works while WS reconnects)"
  artifacts:
    - path: "internal/driver/binance/ws_client.go"
      provides: "Binance WebSocket client"
      exports: ["WSClient", "NewWSClient"]
      min_lines: 150
    - path: "internal/driver/binance/ws_messages.go"
      provides: "WebSocket message types"
      exports: ["WSTicker", "WSDepthUpdate", "WSTrade", "WSBookTicker"]
    - path: "internal/driver/binance/subscription.go"
      provides: "Subscription management"
      exports: ["SubscriptionManager"]
  key_links:
    - from: "internal/driver/binance/ws_client.go"
      to: "lxzan/gws"
      via: "WebSocket library"
      pattern: "gws\\.(NewClient|EventHandler)"
    - from: "internal/driver/binance/ws_client.go"
      to: "internal/driver/binance/subscription.go"
      via: "resubscribe on reconnect"
      pattern: "subscriptions\\."
---

<objective>
Implement Binance WebSocket client with automatic reconnection and subscription restoration.

Purpose: Provide real-time streaming data from Binance with fault-tolerant reconnection.
Output: WSClient with gws integration, exponential backoff, subscription manager
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AGENTS.md

# Domain models from Plan 01
@pkg/domain/types.go
@pkg/domain/decimal.go
@pkg/errors/errors.go

# Binance URLs from Plan 02
@internal/driver/binance/urls.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket message types</name>
  <files>
    internal/driver/binance/ws_messages.go
  </files>
  <action>
Create internal/driver/binance/ws_messages.go with WebSocket message types:

```go
package binance

import (
    "encoding/json"
    "time"
    
    "github.com/user/exchange-connector/pkg/domain"
)

// WSMessage is the base WebSocket message wrapper.
type WSMessage struct {
    Stream string          `json:"stream"`
    Data   json.RawMessage `json:"data"`
}

// WSTicker represents Binance ticker update.
// Stream: <symbol>@ticker
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#individual-symbol-mini-ticker-stream
type WSTicker struct {
    EventType string `json:"e"` // "24hrMiniTicker"
    EventTime int64  `json:"E"` // Event time
    Symbol    string `json:"s"` // Symbol
    // Prices and quantities as strings (need parsing to Decimal)
    LastPrice     string `json:"c"` // Last price
    OpenPrice     string `json:"o"` // Open price
    HighPrice     string `json:"h"` // High price
    LowPrice      string `json:"l"` // Low price
    Volume        string `json:"v"` // Base asset volume
    QuoteVolume   string `json:"q"` // Quote asset volume
    OpenTime      int64  `json:"O"` // Statistics open time
    CloseTime     int64  `json:"C"` // Statistics close time
    FirstTradeID  int64  `json:"F"` // First trade ID
    LastTradeID   int64  `json:"L"` // Last trade ID
    TradeCount    int64  `json:"n"` // Total number of trades
}

// ToDomain converts WSTicker to domain.Ticker.
func (wt *WSTicker) ToDomain() (*domain.Ticker, error) {
    lastPrice, err := domain.NewDecimal(wt.LastPrice)
    if err != nil {
        return nil, err
    }
    highPrice, err := domain.NewDecimal(wt.HighPrice)
    if err != nil {
        return nil, err
    }
    lowPrice, err := domain.NewDecimal(wt.LowPrice)
    if err != nil {
        return nil, err
    }
    volume, err := domain.NewDecimal(wt.Volume)
    if err != nil {
        return nil, err
    }
    quoteVolume, err := domain.NewDecimal(wt.QuoteVolume)
    if err != nil {
        return nil, err
    }
    
    return &domain.Ticker{
        Exchange:    "binance",
        Symbol:      domain.NormalizeSymbol(wt.Symbol),
        LastPrice:   lastPrice,
        HighPrice:   highPrice,
        LowPrice:    lowPrice,
        Volume:      volume,
        QuoteVolume: quoteVolume,
        Timestamp:   time.UnixMilli(wt.EventTime),
    }, nil
}

// WSBookTicker represents best price update.
// Stream: <symbol>@bookTicker
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#individual-symbol-book-ticker-streams
type WSBookTicker struct {
    UpdateID   int64  `json:"u"` // Update ID
    Symbol     string `json:"s"` // Symbol
    BidPrice   string `json:"b"` // Best bid price
    BidQty     string `json:"B"` // Best bid quantity
    AskPrice   string `json:"a"` // Best ask price
    AskQty     string `json:"A"` // Best ask quantity
    EventTime  int64  `json:"E"` // Event time (for combined streams)
}

// ToDomain converts WSBookTicker to domain.Ticker.
func (wbt *WSBookTicker) ToDomain() (*domain.Ticker, error) {
    bidPrice, err := domain.NewDecimal(wbt.BidPrice)
    if err != nil {
        return nil, err
    }
    bidQty, err := domain.NewDecimal(wbt.BidQty)
    if err != nil {
        return nil, err
    }
    askPrice, err := domain.NewDecimal(wbt.AskPrice)
    if err != nil {
        return nil, err
    }
    askQty, err := domain.NewDecimal(wbt.AskQty)
    if err != nil {
        return nil, err
    }
    
    timestamp := time.Now()
    if wbt.EventTime > 0 {
        timestamp = time.UnixMilli(wbt.EventTime)
    }
    
    return &domain.Ticker{
        Exchange:  "binance",
        Symbol:    domain.NormalizeSymbol(wbt.Symbol),
        BidPrice:  bidPrice,
        BidQty:    bidQty,
        AskPrice:  askPrice,
        AskQty:    askQty,
        Timestamp: timestamp,
    }, nil
}

// WSDepthUpdate represents order book depth update.
// Stream: <symbol>@depth or <symbol>@depth@100ms
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#diff-depth-stream
type WSDepthUpdate struct {
    EventType     string     `json:"e"` // "depthUpdate"
    EventTime     int64      `json:"E"` // Event time
    Symbol        string     `json:"s"` // Symbol
    FirstUpdateID int64      `json:"U"` // First update ID in event
    FinalUpdateID int64      `json:"u"` // Final update ID in event
    Bids          [][]string `json:"b"` // Bids [[price, qty], ...]
    Asks          [][]string `json:"a"` // Asks [[price, qty], ...]
}

// ToDomain converts WSDepthUpdate to order book levels.
func (wdu *WSDepthUpdate) ToDomain() (bids, asks []domain.OrderBookLevel, err error) {
    // Parse bids
    for _, bid := range wdu.Bids {
        if len(bid) < 2 {
            continue
        }
        price, pErr := domain.NewDecimal(bid[0])
        if pErr != nil {
            err = pErr
            return
        }
        qty, qErr := domain.NewDecimal(bid[1])
        if qErr != nil {
            err = qErr
            return
        }
        bids = append(bids, domain.OrderBookLevel{
            Price:    price,
            Quantity: qty,
        })
    }
    
    // Parse asks
    for _, ask := range wdu.Asks {
        if len(ask) < 2 {
            continue
        }
        price, pErr := domain.NewDecimal(ask[0])
        if pErr != nil {
            err = pErr
            return
        }
        qty, qErr := domain.NewDecimal(ask[1])
        if qErr != nil {
            err = qErr
            return
        }
        asks = append(asks, domain.OrderBookLevel{
            Price:    price,
            Quantity: qty,
        })
    }
    
    return bids, asks, nil
}

// WSDepthSnapshot represents full order book snapshot.
// Stream: <symbol>@depth (initial message)
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#partial-book-depth-streams
type WSDepthSnapshot struct {
    LastUpdateID int64      `json:"lastUpdateId"`
    Bids         [][]string `json:"bids"`
    Asks         [][]string `json:"asks"`
}

// ToDomain converts WSDepthSnapshot to domain.OrderBook.
func (wds *WSDepthSnapshot) ToDomain(symbol string) (*domain.OrderBook, error) {
    ob := &domain.OrderBook{
        Exchange:  "binance",
        Symbol:    domain.NormalizeSymbol(symbol),
        UpdateID:  wds.LastUpdateID,
        Timestamp: time.Now(),
    }
    
    // Parse bids
    for _, bid := range wds.Bids {
        if len(bid) < 2 {
            continue
        }
        price, err := domain.NewDecimal(bid[0])
        if err != nil {
            return nil, err
        }
        qty, err := domain.NewDecimal(bid[1])
        if err != nil {
            return nil, err
        }
        ob.Bids = append(ob.Bids, domain.OrderBookLevel{
            Price:    price,
            Quantity: qty,
        })
    }
    
    // Parse asks
    for _, ask := range wds.Asks {
        if len(ask) < 2 {
            continue
        }
        price, err := domain.NewDecimal(ask[0])
        if err != nil {
            return nil, err
        }
        qty, err := domain.NewDecimal(ask[1])
        if err != nil {
            return nil, err
        }
        ob.Asks = append(ob.Asks, domain.OrderBookLevel{
            Price:    price,
            Quantity: qty,
        })
    }
    
    return ob, nil
}

// WSTrade represents a single trade.
// Stream: <symbol>@trade or <symbol>@aggTrade
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#trade-streams
type WSTrade struct {
    EventType string `json:"e"` // "trade" or "aggTrade"
    EventTime int64  `json:"E"` // Event time
    Symbol    string `json:"s"` // Symbol
    TradeID   int64  `json:"t"` // Trade ID
    Price     string `json:"p"` // Price
    Quantity  string `json:"q"` // Quantity
    BuyerID   int64  `json:"b"` // Buyer order ID
    SellerID  int64  `json:"a"` // Seller order ID
    TradeTime int64  `json:"T"` // Trade time
    IsBuyerMaker bool `json:"m"` // Is buyer the maker?
}

// ToDomain converts WSTrade to domain.Trade.
func (wt *WSTrade) ToDomain() (*domain.Trade, error) {
    price, err := domain.NewDecimal(wt.Price)
    if err != nil {
        return nil, err
    }
    qty, err := domain.NewDecimal(wt.Quantity)
    if err != nil {
        return nil, err
    }
    
    return &domain.Trade{
        Exchange: "binance",
        Symbol:   domain.NormalizeSymbol(wt.Symbol),
        TradeID:  string(rune(wt.TradeID)),
        Price:    price,
        Quantity: qty,
        Time:     time.UnixMilli(wt.TradeTime),
        IsBuyer:  !wt.IsBuyerMaker,
        IsMaker:  wt.IsBuyerMaker,
    }, nil
}

// WSUserMessage represents user data stream message.
// Stream: User data stream (listen key required)
type WSUserMessage struct {
    EventType string          `json:"e"`
    EventTime int64           `json:"E"`
    Data      json.RawMessage `json:"-"`
}

// WSOrderUpdate represents order update from user data stream.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#order-update
type WSOrderUpdate struct {
    EventType           string `json:"e"` // "executionReport"
    EventTime           int64  `json:"E"`
    Symbol              string `json:"s"`
    ClientOrderID       string `json:"c"`
    Side                string `json:"S"` // BUY or SELL
    OrderType           string `json:"o"` // LIMIT, MARKET, etc.
    TimeInForce         string `json:"f"` // GTC, IOC, FOK
    OriginalQuantity    string `json:"q"` // Original quantity
    OriginalPrice       string `json:"p"` // Original price
    AveragePrice        string `json:"a"` // Average price
    OrderStatus         string `json:"X"` // NEW, FILLED, etc.
    OrderID             int64  `json:"i"`
    LastExecutedQty     string `json:"l"` // Last executed quantity
    CumulativeFilledQty string `json:"z"` // Cumulative filled quantity
    LastExecutedPrice   string `json:"L"` // Last executed price
    CommissionAsset     string `json:"N"` // Commission asset
    Commission          string `json:"n"` // Commission
    TradeID             int64  `json:"t"` // Trade ID
    TradeTime           int64  `json:"T"` // Trade time
}

// ToDomain converts WSOrderUpdate to domain.Order.
func (wou *WSOrderUpdate) ToDomain() (*domain.Order, error) {
    qty, err := domain.NewDecimal(wou.OriginalQuantity)
    if err != nil {
        return nil, err
    }
    price, err := domain.NewDecimal(wou.OriginalPrice)
    if err != nil {
        return nil, err
    }
    avgPrice, err := domain.NewDecimal(wou.AveragePrice)
    if err != nil {
        return nil, err
    }
    executedQty, err := domain.NewDecimal(wou.CumulativeFilledQty)
    if err != nil {
        return nil, err
    }
    commission, err := domain.NewDecimal(wou.Commission)
    if err != nil {
        // Commission might be empty
        commission = domain.Zero()
    }
    
    return &domain.Order{
        Exchange:       "binance",
        Symbol:         domain.NormalizeSymbol(wou.Symbol),
        OrderID:        string(rune(wou.OrderID)),
        ClientOrderID:  wou.ClientOrderID,
        Side:           domain.OrderSide(wou.Side),
        Type:           domain.OrderType(wou.OrderType),
        Status:         domain.OrderStatus(wou.OrderStatus),
        Price:          price,
        Quantity:       qty,
        ExecutedQty:    executedQty,
        AvgPrice:       avgPrice,
        Commission:     commission,
        CommissionAsset: wou.CommissionAsset,
        UpdatedAt:      time.UnixMilli(wou.TradeTime),
        TimeInForce:    wou.TimeInForce,
    }, nil
}

// WSBalanceUpdate represents account balance update.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#balance-update
type WSBalanceUpdate struct {
    EventType string `json:"e"` // "balanceUpdate"
    EventTime int64  `json:"E"`
    Asset     string `json:"a"` // Asset
    BalanceDelta string `json:"d"` // Balance delta
    ClearTime int64  `json:"T"` // Clear time
}
```

CRITICAL RULES:
- All price/quantity fields are strings in Binance JSON - MUST parse to Decimal
- WSTicker and WSDepthUpdate are DIFFERENT formats (snapshot vs delta)
- Order book updates require sequence validation (FirstUpdateID/FinalUpdateID)
- User data stream requires listen key (not implemented in this phase)
</action>
  <verify>
    go build ./internal/driver/binance/...
    go vet ./internal/driver/binance/...
  </verify>
  <done>
    internal/driver/binance/ws_messages.go exports WSTicker, WSBookTicker, WSDepthUpdate, WSTrade, WSOrderUpdate with ToDomain conversion methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create subscription manager</name>
  <files>
    internal/driver/binance/subscription.go
  </files>
  <action>
Create internal/driver/binance/subscription.go with subscription tracking:

```go
package binance

import (
    "sync"
    
    "github.com/rs/zerolog/log"
)

// SubscriptionManager tracks active WebSocket subscriptions.
// Used for automatic resubscription on reconnect.
type SubscriptionManager struct {
    mutex         sync.RWMutex
    subscriptions map[string]bool // stream name -> active
}

// NewSubscriptionManager creates a new SubscriptionManager.
func NewSubscriptionManager() *SubscriptionManager {
    return &SubscriptionManager{
        subscriptions: make(map[string]bool),
    }
}

// Subscribe registers a new subscription.
// Returns true if this is a new subscription (not already subscribed).
func (sm *SubscriptionManager) Subscribe(stream string) bool {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    if _, exists := sm.subscriptions[stream]; exists {
        return false // Already subscribed
    }
    
    sm.subscriptions[stream] = true
    log.Debug().Str("stream", stream).Msg("subscription registered")
    return true
}

// Unsubscribe removes a subscription.
// Returns true if the subscription existed.
func (sm *SubscriptionManager) Unsubscribe(stream string) bool {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    if _, exists := sm.subscriptions[stream]; !exists {
        return false // Not subscribed
    }
    
    delete(sm.subscriptions, stream)
    log.Debug().Str("stream", stream).Msg("subscription unregistered")
    return true
}

// IsSubscribed checks if a stream is subscribed.
func (sm *SubscriptionManager) IsSubscribed(stream string) bool {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    _, exists := sm.subscriptions[stream]
    return exists
}

// Streams returns all subscribed stream names.
func (sm *SubscriptionManager) Streams() []string {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    streams := make([]string, 0, len(sm.subscriptions))
    for stream := range sm.subscriptions {
        streams = append(streams, stream)
    }
    return streams
}

// Count returns the number of active subscriptions.
func (sm *SubscriptionManager) Count() int {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    return len(sm.subscriptions)
}

// Clear removes all subscriptions.
func (sm *SubscriptionManager) Clear() {
    sm.mutex.Lock()
    defer sm.mutex.Unlock()
    
    clear(sm.subscriptions)
}

// StreamBuilder helps build Binance stream names.
type StreamBuilder struct {
    symbol string // Exchange symbol format (e.g., "btcusdt")
}

// NewStreamBuilder creates a StreamBuilder for a symbol.
func NewStreamBuilder(symbol string) *StreamBuilder {
    // Convert normalized symbol to exchange format
    exchangeSymbol := domain.ExchangeSymbol(symbol)
    return &StreamBuilder{
        symbol: strings.ToLower(exchangeSymbol),
    }
}

// Ticker returns the ticker stream name.
func (sb *StreamBuilder) Ticker() string {
    return sb.symbol + WSTicker
}

// BookTicker returns the best price stream name.
func (sb *StreamBuilder) BookTicker() string {
    return sb.symbol + WSBookTicker
}

// Depth returns the depth stream name.
func (sb *StreamBuilder) Depth() string {
    return sb.symbol + WSDepth
}

// DepthWithSpeed returns the depth stream name with update speed.
// speed: 100ms or 1000ms
func (sb *StreamBuilder) DepthWithSpeed(speed string) string {
    return sb.symbol + WSDepth + "@" + speed
}

// Trade returns the trade stream name.
func (sb *StreamBuilder) Trade() string {
    return sb.symbol + WSTrade
}

// AggTrade returns the aggregated trade stream name.
func (sb *StreamBuilder) AggTrade() string {
    return sb.symbol + WSAggTrade
}

// Kline returns the kline stream name.
// interval: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M
func (sb *StreamBuilder) Kline(interval string) string {
    return sb.symbol + WSKline + "_" + interval
}

// CombineStreams creates a combined stream URL for multiple streams.
// Binance allows subscribing to multiple streams in a single connection.
func CombineStreams(streams []string) string {
    if len(streams) == 0 {
        return ""
    }
    if len(streams) == 1 {
        return streams[0]
    }
    return "/stream?streams=" + strings.Join(streams, "/")
}
```

Import strings package at top of file.

CRITICAL RULES:
- Stream names MUST be lowercase for Binance
- Combined streams format: /stream?streams=stream1/stream2/...
- SubscriptionManager MUST be thread-safe (sync.RWMutex)
- Track subscriptions for automatic resubscription on reconnect
</action>
  <verify>
    go build ./internal/driver/binance/...
    go vet ./internal/driver/binance/...
  </verify>
  <done>
    internal/driver/binance/subscription.go exports SubscriptionManager with Subscribe/Unsubscribe/Streams methods, StreamBuilder for creating stream names
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket client with reconnection</name>
  <files>
    internal/driver/binance/ws_client.go
  </files>
  <action>
Create internal/driver/binance/ws_client.go with gws integration:

```go
package binance

import (
    "context"
    "fmt"
    "math"
    "net/http"
    "sync"
    "sync/atomic"
    "time"
    
    "github.com/lxzan/gws"
    "github.com/rs/zerolog/log"
    
    "github.com/user/exchange-connector/pkg/domain"
    "github.com/user/exchange-connector/pkg/errors"
)

// WSClient implements Binance WebSocket client with automatic reconnection.
// Documentation: https://binance-docs.github.io/apidocs/spot/en/#websocket-market-streams
type WSClient struct {
    // Configuration
    baseURL       string
    pingInterval  time.Duration
    reconnectCfg  ReconnectConfig
    
    // State
    conn         atomic.Pointer[gws.Conn]
    connected    atomic.Bool
    connecting   atomic.Bool
    stopCh       chan struct{}
    
    // Subscription management
    subscriptions *SubscriptionManager
    subMutex     sync.Mutex
    
    // Callbacks
    onTicker     func(*domain.Ticker)
    onOrderBook  func(*domain.OrderBook)
    onTrade      func(*domain.Trade)
    onOrder      func(*domain.Order)
    onConnect    func()
    onDisconnect func(error)
    
    // Context for cancellation
    ctx    context.Context
    cancel context.CancelFunc
}

// ReconnectConfig contains reconnection settings.
type ReconnectConfig struct {
    InitialDelay time.Duration // Initial delay before first reconnect
    MaxDelay     time.Duration // Maximum delay between reconnects
    MaxAttempts  int           // Maximum attempts (0 = infinite)
    Jitter       float64       // Jitter factor (0-1, e.g., 0.1 = 10%)
}

// DefaultReconnectConfig returns the default reconnection configuration.
func DefaultReconnectConfig() ReconnectConfig {
    return ReconnectConfig{
        InitialDelay: 1 * time.Second,
        MaxDelay:     60 * time.Second,
        MaxAttempts:  0, // Infinite
        Jitter:       0.1,
    }
}

// WSConfig contains WebSocket client configuration.
type WSConfig struct {
    BaseURL      string           // WebSocket base URL
    Testnet      bool             // Use testnet
    PingInterval time.Duration    // Ping interval (default 20s, max 1 min before disconnect)
    Reconnect    ReconnectConfig  // Reconnection settings
}

// NewWSClient creates a new Binance WebSocket client.
func NewWSClient(cfg WSConfig) *WSClient {
    // Set defaults
    if cfg.BaseURL == "" {
        if cfg.Testnet {
            cfg.BaseURL = TestnetWebSocketURL
        } else {
            cfg.BaseURL = BaseWebSocketURL
        }
    }
    if cfg.PingInterval == 0 {
        cfg.PingInterval = 20 * time.Second
    }
    if cfg.PingInterval > 55*time.Second {
        cfg.PingInterval = 55 * time.Second // Leave buffer before 1 min disconnect
    }
    if cfg.Reconnect.MaxDelay == 0 {
        cfg.Reconnect = DefaultReconnectConfig()
    }
    
    ctx, cancel := context.WithCancel(context.Background())
    
    return &WSClient{
        baseURL:       cfg.BaseURL,
        pingInterval:  cfg.PingInterval,
        reconnectCfg:  cfg.Reconnect,
        subscriptions: NewSubscriptionManager(),
        stopCh:        make(chan struct{}),
        ctx:           ctx,
        cancel:        cancel,
    }
}

// OnTicker sets the ticker callback.
func (ws *WSClient) OnTicker(handler func(*domain.Ticker)) {
    ws.onTicker = handler
}

// OnOrderBook sets the order book callback.
func (ws *WSClient) OnOrderBook(handler func(*domain.OrderBook)) {
    ws.onOrderBook = handler
}

// OnTrade sets the trade callback.
func (ws *WSClient) OnTrade(handler func(*domain.Trade)) {
    ws.onTrade = handler
}

// OnOrder sets the order update callback.
func (ws *WSClient) OnOrder(handler func(*domain.Order)) {
    ws.onOrder = handler
}

// OnConnect sets the connection established callback.
func (ws *WSClient) OnConnect(handler func()) {
    ws.onConnect = handler
}

// OnDisconnect sets the disconnection callback.
func (ws *WSClient) OnDisconnect(handler func(error)) {
    ws.onDisconnect = handler
}

// Connect establishes the WebSocket connection.
func (ws *WSClient) Connect() error {
    if ws.connecting.Swap(true) {
        return nil // Already connecting
    }
    defer ws.connecting.Store(false)
    
    if ws.connected.Load() {
        return nil // Already connected
    }
    
    // Build stream URL from subscriptions
    streams := ws.subscriptions.Streams()
    if len(streams) == 0 {
        // No subscriptions yet - connect to a minimal stream
        streams = []string{"btcusdt@ticker"}
    }
    
    streamURL := ws.baseURL + CombineStreams(streams)
    
    // Create gws client
    option := &gws.ClientOption{
        Addr: streamURL,
        Config: gws.Config{
            EnableCompression: false,
        },
        RequestHeader: http.Header{
            "User-Agent": []string{"exchange-connector/1.0"},
        },
    }
    
    conn, _, err := gws.NewClient(ws, option)
    if err != nil {
        return errors.NewConnectionError("binance", "websocket", "connect failed", true, err)
    }
    
    ws.conn.Store(conn)
    ws.connected.Store(true)
    
    // Start reading messages
    go conn.ReadMessage()
    
    log.Info().Str("url", streamURL).Msg("WebSocket connected")
    
    // Notify callback
    if ws.onConnect != nil {
        go ws.onConnect()
    }
    
    return nil
}

// Disconnect closes the WebSocket connection.
func (ws *WSClient) Disconnect() error {
    conn := ws.conn.Load()
    if conn == nil {
        return nil
    }
    
    ws.connected.Store(false)
    return conn.Close()
}

// Close permanently closes the client and stops reconnection.
func (ws *WSClient) Close() error {
    ws.cancel()
    close(ws.stopCh)
    return ws.Disconnect()
}

// IsConnected returns true if connected.
func (ws *WSClient) IsConnected() bool {
    return ws.connected.Load()
}

// Subscribe subscribes to a stream.
func (ws *WSClient) Subscribe(stream string) error {
    isNew := ws.subscriptions.Subscribe(stream)
    if !isNew {
        return nil // Already subscribed
    }
    
    // If connected, need to resubscribe via new connection
    // (Binance doesn't support dynamic subscribe on existing connection)
    if ws.connected.Load() {
        go ws.reconnect()
    }
    
    return nil
}

// Unsubscribe removes a subscription.
func (ws *WSClient) Unsubscribe(stream string) error {
    existed := ws.subscriptions.Unsubscribe(stream)
    if !existed {
        return nil // Not subscribed
    }
    
    // If connected, need to reconnect without this stream
    if ws.connected.Load() {
        go ws.reconnect()
    }
    
    return nil
}

// reconnect handles reconnection with exponential backoff.
func (ws *WSClient) reconnect() {
    if ws.connecting.Swap(true) {
        return // Already reconnecting
    }
    
    ws.connected.Store(false)
    
    attempt := 0
    for {
        select {
        case <-ws.stopCh:
            return
        case <-ws.ctx.Done():
            return
        default:
        }
        
        // Calculate delay with exponential backoff and jitter
        delay := ws.calculateBackoff(attempt)
        
        log.Warn().
            Int("attempt", attempt).
            Dur("delay", delay).
            Msg("WebSocket reconnecting")
        
        time.Sleep(delay)
        
        // Attempt connection
        if err := ws.Connect(); err != nil {
            log.Error().Err(err).Int("attempt", attempt).Msg("reconnect failed")
            
            attempt++
            
            // Check max attempts
            if ws.reconnectCfg.MaxAttempts > 0 && attempt >= ws.reconnectCfg.MaxAttempts {
                log.Error().Msg("max reconnect attempts reached")
                ws.connecting.Store(false)
                return
            }
            
            continue
        }
        
        // Resubscribe to all streams (done automatically in Connect via subscriptions.Streams())
        log.Info().Int("subscriptions", ws.subscriptions.Count()).Msg("WebSocket reconnected and resubscribed")
        
        ws.connecting.Store(false)
        return
    }
}

// calculateBackoff calculates the backoff delay with exponential growth and jitter.
func (ws *WSClient) calculateBackoff(attempt int) time.Duration {
    // Exponential backoff: delay = initialDelay * 2^attempt
    delay := float64(ws.reconnectCfg.InitialDelay)
    delay *= math.Pow(2, float64(attempt))
    
    // Cap at max delay
    if delay > float64(ws.reconnectCfg.MaxDelay) {
        delay = float64(ws.reconnectCfg.MaxDelay)
    }
    
    // Add jitter
    if ws.reconnectCfg.Jitter > 0 {
        jitter := delay * ws.reconnectCfg.Jitter
        delay += (jitter * 2 * (float64(time.Now().UnixNano()%1000) / 1000)) - jitter
    }
    
    return time.Duration(delay)
}

// gws.EventHandler implementation

// OnOpen is called when the WebSocket connection is established.
func (ws *WSClient) OnOpen(conn *gws.Conn) {
    log.Info().Msg("WebSocket OnOpen")
    
    // Start ping ticker
    go func() {
        ticker := time.NewTicker(ws.pingInterval)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                if !ws.connected.Load() {
                    return
                }
                conn.WritePing(nil)
            case <-ws.stopCh:
                return
            case <-ws.ctx.Done():
                return
            }
        }
    }()
}

// OnClose is called when the WebSocket connection is closed.
func (ws *WSClient) OnClose(conn *gws.Conn, err error) {
    log.Error().Err(err).Msg("WebSocket OnClose")
    
    ws.connected.Store(false)
    
    // Notify callback
    if ws.onDisconnect != nil {
        go ws.onDisconnect(err)
    }
    
    // Attempt reconnection
    select {
    case <-ws.stopCh:
        return
    case <-ws.ctx.Done():
        return
    default:
        go ws.reconnect()
    }
}

// OnPing is called when a ping frame is received.
func (ws *WSClient) OnPing(conn *gws.Conn, payload []byte) {
    // Respond with pong
    conn.WritePong(payload)
}

// OnPong is called when a pong frame is received.
func (ws *WSClient) OnPong(conn *gws.Conn, payload []byte) {
    log.Debug().Msg("WebSocket pong received")
}

// OnMessage is called when a message is received.
func (ws *WSClient) OnMessage(conn *gws.Conn, message *gws.Message) {
    defer message.Close()
    
    data := message.Data.Bytes()
    
    // Parse message
    var msg WSMessage
    if err := json.Unmarshal(data, &msg); err != nil {
        log.Error().Err(err).Str("data", string(data)).Msg("failed to parse WebSocket message")
        return
    }
    
    // Route based on stream type
    ws.routeMessage(msg.Stream, msg.Data)
}

// routeMessage routes a message to the appropriate handler.
func (ws *WSClient) routeMessage(stream string, data []byte) {
    // Determine message type from stream name
    switch {
    case strings.HasSuffix(stream, "@ticker"):
        ws.handleTicker(data)
    case strings.HasSuffix(stream, "@bookTicker"):
        ws.handleBookTicker(data)
    case strings.HasSuffix(stream, "@depth") || strings.Contains(stream, "@depth@"):
        ws.handleDepth(data, stream)
    case strings.HasSuffix(stream, "@trade") || strings.HasSuffix(stream, "@aggTrade"):
        ws.handleTrade(data)
    default:
        log.Debug().Str("stream", stream).Msg("unhandled stream type")
    }
}

// handleTicker handles ticker messages.
func (ws *WSClient) handleTicker(data []byte) {
    var ticker WSTicker
    if err := json.Unmarshal(data, &ticker); err != nil {
        log.Error().Err(err).Msg("failed to parse ticker")
        return
    }
    
    domainTicker, err := ticker.ToDomain()
    if err != nil {
        log.Error().Err(err).Msg("failed to convert ticker")
        return
    }
    
    if ws.onTicker != nil {
        ws.safeCallback(func() {
            ws.onTicker(domainTicker)
        })
    }
}

// handleBookTicker handles best price messages.
func (ws *WSClient) handleBookTicker(data []byte) {
    var bookTicker WSBookTicker
    if err := json.Unmarshal(data, &bookTicker); err != nil {
        log.Error().Err(err).Msg("failed to parse book ticker")
        return
    }
    
    domainTicker, err := bookTicker.ToDomain()
    if err != nil {
        log.Error().Err(err).Msg("failed to convert book ticker")
        return
    }
    
    if ws.onTicker != nil {
        ws.safeCallback(func() {
            ws.onTicker(domainTicker)
        })
    }
}

// handleDepth handles order book depth messages.
func (ws *WSClient) handleDepth(data []byte, stream string) {
    // Try parsing as update first
    var depthUpdate WSDepthUpdate
    if err := json.Unmarshal(data, &depthUpdate); err == nil && depthUpdate.EventType == "depthUpdate" {
        bids, asks, err := depthUpdate.ToDomain()
        if err != nil {
            log.Error().Err(err).Msg("failed to convert depth update")
            return
        }
        
        // Extract symbol from stream
        symbol := strings.Split(stream, "@")[0]
        
        ob := &domain.OrderBook{
            Exchange:  "binance",
            Symbol:    domain.NormalizeSymbol(symbol),
            Bids:      bids,
            Asks:      asks,
            UpdateID:  depthUpdate.FinalUpdateID,
            Timestamp: time.UnixMilli(depthUpdate.EventTime),
        }
        
        if ws.onOrderBook != nil {
            ws.safeCallback(func() {
                ws.onOrderBook(ob)
            })
        }
        return
    }
    
    // Try parsing as snapshot
    var snapshot WSDepthSnapshot
    if err := json.Unmarshal(data, &snapshot); err != nil {
        log.Error().Err(err).Msg("failed to parse depth snapshot")
        return
    }
    
    symbol := strings.Split(stream, "@")[0]
    ob, err := snapshot.ToDomain(symbol)
    if err != nil {
        log.Error().Err(err).Msg("failed to convert depth snapshot")
        return
    }
    
    if ws.onOrderBook != nil {
        ws.safeCallback(func() {
            ws.onOrderBook(ob)
        })
    }
}

// handleTrade handles trade messages.
func (ws *WSClient) handleTrade(data []byte) {
    var trade WSTrade
    if err := json.Unmarshal(data, &trade); err != nil {
        log.Error().Err(err).Msg("failed to parse trade")
        return
    }
    
    domainTrade, err := trade.ToDomain()
    if err != nil {
        log.Error().Err(err).Msg("failed to convert trade")
        return
    }
    
    if ws.onTrade != nil {
        ws.safeCallback(func() {
            ws.onTrade(domainTrade)
        })
    }
}

// safeCallback executes a callback with panic recovery.
func (ws *WSClient) safeCallback(fn func()) {
    defer func() {
        if r := recover(); r != nil {
            log.Error().Interface("panic", r).Msg("callback panic recovered")
        }
    }()
    fn()
}

// Subscriptions returns the subscription manager for external access.
func (ws *WSClient) Subscriptions() *SubscriptionManager {
    return ws.subscriptions
}
```

CRITICAL RULES:
- gws requires OnOpen/OnClose/OnPing/OnPong/OnMessage handlers
- Ping MUST be sent within 1 minute to prevent disconnect
- Exponential backoff: delay = initialDelay * 2^attempt (capped at max)
- Add jitter (10%) to prevent thundering herd
- Callbacks MUST be wrapped in panic recovery
- Reconnection automatically resubscribes to all streams
- Binance doesn't support dynamic subscribe on existing connection - need reconnect
</action>
  <verify>
    go build ./internal/driver/binance/...
    go vet ./internal/driver/binance/...
    
    # Verify gws usage
    grep -n "gws\." internal/driver/binance/ws_client.go
  </verify>
  <done>
    internal/driver/binance/ws_client.go exports WSClient with Connect/Subscribe/OnTicker/OnOrderBook, automatic reconnection with exponential backoff, panic recovery for callbacks
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify WebSocket client builds:
   ```bash
   go build ./internal/driver/binance/...
   go vet ./internal/driver/binance/...
   ```

2. Verify gws integration:
   ```bash
   grep -n "gws\." internal/driver/binance/ws_client.go | head -5
   ```

3. Verify reconnection logic:
   ```bash
   grep -n "reconnect" internal/driver/binance/ws_client.go
   ```

4. Verify no float64 in financial calculations:
   ```bash
   ! grep -r "float64" internal/driver/binance/ws_messages.go || echo "WARNING: float64 found"
   ```
</verification>

<success_criteria>
- internal/driver/binance/ws_messages.go exports all WebSocket message types with ToDomain
- internal/driver/binance/subscription.go exports SubscriptionManager
- internal/driver/binance/ws_client.go exports WSClient with gws integration
- Automatic reconnection with exponential backoff
- All subscriptions restored after reconnect
- Ping/pong handling for connection keepalive
- Panic recovery in callbacks
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-binance/01-03-SUMMARY.md`
</output>
