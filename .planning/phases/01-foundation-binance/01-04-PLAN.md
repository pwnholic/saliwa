---
phase: 01-foundation-binance
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - internal/circuit/breaker.go
  - internal/sync/clock.go
  - internal/sync/nonce.go
  - pkg/connector/connector.go
  - pkg/connector/config.go
  - pkg/connector/events.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Developer can call connector.Start() to begin Binance connection"
    - "Circuit breaker prevents requests when exchange becomes unhealthy"
    - "Clock is synchronized with exchange server time (<500ms offset)"
    - "Nonces are unique for replay protection"
    - "Developer can subscribe to ticker/orderbook events via callbacks"
    - "Developer can call connector.Stop() for graceful shutdown"
  artifacts:
    - path: "internal/circuit/breaker.go"
      provides: "Circuit breaker implementation"
      exports: ["Breaker", "NewBreaker"]
    - path: "internal/sync/clock.go"
      provides: "Clock synchronization actor"
      exports: ["ClockSync", "NewClockSync"]
    - path: "pkg/connector/connector.go"
      provides: "Public Connector API"
      exports: ["Connector", "New", "Config"]
      min_lines: 100
    - path: "pkg/connector/config.go"
      provides: "Configuration types"
      exports: ["Config", "ExchangeConfig", "RateLimitConfig"]
  key_links:
    - from: "pkg/connector/connector.go"
      to: "internal/driver/binance/rest_client.go"
      via: "REST client"
      pattern: "restClient\\."
    - from: "pkg/connector/connector.go"
      to: "internal/driver/binance/ws_client.go"
      via: "WebSocket client"
      pattern: "wsClient\\."
    - from: "pkg/connector/connector.go"
      to: "internal/circuit/breaker.go"
      via: "circuit breaker"
      pattern: "breaker\\."
---

<objective>
Implement resilience layer (circuit breaker, clock sync) and public Connector API that ties all components together.

Purpose: Provide production-ready fault tolerance and clean public API for exchange connectivity.
Output: Circuit breaker, Clock sync actor, public Connector with Start/Stop/Subscribe methods
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AGENTS.md

# Domain models from Plan 01
@pkg/domain/types.go
@pkg/domain/decimal.go
@pkg/errors/errors.go

# REST client from Plan 02
@internal/driver/binance/rest_client.go
@internal/driver/binance/signer.go

# WebSocket client from Plan 03
@internal/driver/binance/ws_client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create circuit breaker</name>
  <files>
    internal/circuit/breaker.go
  </files>
  <action>
Create internal/circuit/breaker.go with circuit breaker implementation:

```go
// Package circuit implements circuit breaker pattern for fault tolerance.
// Used to prevent cascading failures when exchange becomes unhealthy.

package circuit

import (
    "sync"
    "time"
    
    "github.com/sony/gobreaker"
    "github.com/rs/zerolog/log"
    
    "github.com/user/exchange-connector/pkg/errors"
)

// State represents the circuit breaker state.
type State int

const (
    StateClosed State = iota
    StateHalfOpen
    StateOpen
)

// String returns the string representation of the state.
func (s State) String() string {
    switch s {
    case StateClosed:
        return "closed"
    case StateHalfOpen:
        return "half-open"
    case StateOpen:
        return "open"
    default:
        return "unknown"
    }
}

// Breaker implements a circuit breaker for exchange operations.
// States:
// - Closed: Normal operation, requests pass through
// - Open: Requests blocked, waiting for timeout
// - Half-Open: Testing recovery, limited requests allowed
type Breaker struct {
    exchange string
    breaker  *gobreaker.CircuitBreaker
    config   Config
    
    // Metrics
    mutex          sync.RWMutex
    totalRequests  int64
    totalFailures  int64
    totalSuccesses int64
    lastFailure    time.Time
    lastStateChange time.Time
}

// Config contains circuit breaker configuration.
type Config struct {
    // Thresholds
    MaxFailures    int           // Failures before opening (default: 5)
    SuccessThreshold int         // Successes in half-open to close (default: 3)
    
    // Timeouts
    OpenTimeout    time.Duration // Time before half-open (default: 30s)
    
    // Callbacks
    OnStateChange  func(from, to State)
}

// DefaultConfig returns the default circuit breaker configuration.
func DefaultConfig() Config {
    return Config{
        MaxFailures:     5,
        SuccessThreshold: 3,
        OpenTimeout:     30 * time.Second,
    }
}

// NewBreaker creates a new circuit breaker.
func NewBreaker(exchange string, cfg Config) *Breaker {
    if cfg.MaxFailures == 0 {
        cfg.MaxFailures = DefaultConfig().MaxFailures
    }
    if cfg.SuccessThreshold == 0 {
        cfg.SuccessThreshold = DefaultConfig().SuccessThreshold
    }
    if cfg.OpenTimeout == 0 {
        cfg.OpenTimeout = DefaultConfig().OpenTimeout
    }
    
    name := exchange + "-breaker"
    
    breakerSettings := gobreaker.Settings{
        Name:        name,
        MaxRequests: uint32(cfg.SuccessThreshold),
        Interval:    0, // Don't clear counts periodically
        Timeout:     cfg.OpenTimeout,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures >= uint32(cfg.MaxFailures)
        },
        OnStateChange: func(name string, from, to gobreaker.State) {
            log.Info().
                Str("exchange", exchange).
                Str("from", from.String()).
                Str("to", to.String()).
                Msg("circuit breaker state changed")
            
            if cfg.OnStateChange != nil {
                cfg.OnStateChange(State(from), State(to))
            }
        },
    }
    
    return &Breaker{
        exchange:       exchange,
        breaker:        gobreaker.NewCircuitBreaker(breakerSettings),
        config:         cfg,
        lastStateChange: time.Now(),
    }
}

// Execute runs the given function through the circuit breaker.
// Returns CircuitBreakerError if the breaker is open.
func (b *Breaker) Execute(fn func() error) error {
    _, err := b.breaker.Execute(func() (interface{}, error) {
        return nil, fn()
    })
    
    if err != nil {
        // Check if it's a circuit breaker error
        if err == gobreaker.ErrOpenState {
            return errors.NewCircuitBreakerError(b.exchange, "open", b.timeToHalfOpen())
        }
        if err == gobreaker.ErrTooManyRequests {
            return errors.NewCircuitBreakerError(b.exchange, "half-open", b.timeToHalfOpen())
        }
        
        // Track failure
        b.recordFailure()
        return err
    }
    
    // Track success
    b.recordSuccess()
    return nil
}

// ExecuteWithResult runs the given function and returns its result.
func (b *Breaker) ExecuteWithResult(fn func() (interface{}, error)) (interface{}, error) {
    result, err := b.breaker.Execute(fn)
    
    if err != nil {
        if err == gobreaker.ErrOpenState {
            return nil, errors.NewCircuitBreakerError(b.exchange, "open", b.timeToHalfOpen())
        }
        if err == gobreaker.ErrTooManyRequests {
            return nil, errors.NewCircuitBreakerError(b.exchange, "half-open", b.timeToHalfOpen())
        }
        
        b.recordFailure()
        return nil, err
    }
    
    b.recordSuccess()
    return result, nil
}

// State returns the current circuit breaker state.
func (b *Breaker) State() State {
    switch b.breaker.State() {
    case gobreaker.StateClosed:
        return StateClosed
    case gobreaker.StateHalfOpen:
        return StateHalfOpen
    case gobreaker.StateOpen:
        return StateOpen
    default:
        return StateClosed
    }
}

// IsOpen returns true if the circuit breaker is open.
func (b *Breaker) IsOpen() bool {
    return b.breaker.State() == gobreaker.StateOpen
}

// IsClosed returns true if the circuit breaker is closed.
func (b *Breaker) IsClosed() bool {
    return b.breaker.State() == gobreaker.StateClosed
}

// IsHalfOpen returns true if the circuit breaker is half-open.
func (b *Breaker) IsHalfOpen() bool {
    return b.breaker.State() == gobreaker.StateHalfOpen
}

// timeToHalfOpen returns the time until the breaker transitions to half-open.
func (b *Breaker) timeToHalfOpen() time.Duration {
    if b.breaker.State() != gobreaker.StateOpen {
        return 0
    }
    
    // Calculate time remaining until timeout
    elapsed := time.Since(b.lastStateChange)
    remaining := b.config.OpenTimeout - elapsed
    if remaining < 0 {
        return 0
    }
    return remaining
}

// Stats returns circuit breaker statistics.
func (b *Breaker) Stats() Stats {
    b.mutex.RLock()
    defer b.mutex.RUnlock()
    
    return Stats{
        Exchange:       b.exchange,
        State:          b.State().String(),
        TotalRequests:  b.totalRequests,
        TotalFailures:  b.totalFailures,
        TotalSuccesses: b.totalSuccesses,
        LastFailure:    b.lastFailure,
    }
}

// Stats contains circuit breaker statistics.
type Stats struct {
    Exchange       string    `json:"exchange"`
    State          string    `json:"state"`
    TotalRequests  int64     `json:"total_requests"`
    TotalFailures  int64     `json:"total_failures"`
    TotalSuccesses int64     `json:"total_successes"`
    LastFailure    time.Time `json:"last_failure"`
}

// recordSuccess records a successful request.
func (b *Breaker) recordSuccess() {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    b.totalRequests++
    b.totalSuccesses++
}

// recordFailure records a failed request.
func (b *Breaker) recordFailure() {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    b.totalRequests++
    b.totalFailures++
    b.lastFailure = time.Now()
}

// Reset resets the circuit breaker to closed state.
func (b *Breaker) Reset() {
    // gobreaker doesn't have a direct reset, so we create a new breaker
    b.breaker = gobreaker.NewCircuitBreaker(gobreaker.Settings{
        Name:        b.exchange + "-breaker",
        MaxRequests: uint32(b.config.SuccessThreshold),
        Interval:    0,
        Timeout:     b.config.OpenTimeout,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures >= uint32(b.config.MaxFailures)
        },
    })
    
    b.mutex.Lock()
    b.lastStateChange = time.Now()
    b.mutex.Unlock()
    
    log.Info().Str("exchange", b.exchange).Msg("circuit breaker reset")
}
```

CRITICAL RULES:
- Three states: Closed (normal), Open (blocked), Half-Open (testing)
- Open on MaxFailures consecutive failures
- Half-Open after OpenTimeout
- Close after SuccessThreshold successes in Half-Open
- Use sony/gobreaker for production-tested implementation
- Return CircuitBreakerError for open/half-open states
</action>
  <verify>
    go build ./internal/circuit/...
    go vet ./internal/circuit/...
  </verify>
  <done>
    internal/circuit/breaker.go exports Breaker with Execute/State/IsOpen/IsClosed methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create clock sync and nonce generator</name>
  <files>
    internal/sync/clock.go
    internal/sync/nonce.go
  </files>
  <action>
Create internal/sync/clock.go with clock synchronization:

```go
// Package sync provides clock synchronization and nonce generation.
// Critical for exchange API signature validation.

package sync

import (
    "sync"
    "sync/atomic"
    "time"
    
    "github.com/rs/zerolog/log"
    
    "github.com/user/exchange-connector/pkg/errors"
)

// ClockSync maintains synchronized time with exchange server.
// Binance requires clock offset < 500ms for signed requests.
type ClockSync struct {
    exchange string
    
    // State
    offset     atomic.Int64 // Server time - Local time (in milliseconds)
    lastSync   atomic.Int64 // Last sync timestamp (Unix milliseconds)
    
    // Configuration
    maxOffset     time.Duration // Maximum allowed offset
    syncInterval  time.Duration // How often to sync
    timeProvider  TimeProvider  // Function to get server time
    
    // Control
    mutex    sync.Mutex
    stopCh   chan struct{}
    running  atomic.Bool
}

// TimeProvider returns the server time in milliseconds.
type TimeProvider func() (int64, error)

// ClockConfig contains clock synchronization configuration.
type ClockConfig struct {
    MaxOffset    time.Duration // Maximum allowed offset (default: 500ms)
    SyncInterval time.Duration // Sync interval (default: 5m)
    TimeProvider TimeProvider  // Function to get server time
}

// DefaultClockConfig returns default clock configuration.
func DefaultClockConfig() ClockConfig {
    return ClockConfig{
        MaxOffset:   500 * time.Millisecond,
        SyncInterval: 5 * time.Minute,
    }
}

// NewClockSync creates a new clock synchronizer.
func NewClockSync(exchange string, cfg ClockConfig) *ClockSync {
    if cfg.MaxOffset == 0 {
        cfg.MaxOffset = DefaultClockConfig().MaxOffset
    }
    if cfg.SyncInterval == 0 {
        cfg.SyncInterval = DefaultClockConfig().SyncInterval
    }
    
    return &ClockSync{
        exchange:     exchange,
        maxOffset:    cfg.MaxOffset,
        syncInterval: cfg.SyncInterval,
        timeProvider: cfg.TimeProvider,
        stopCh:       make(chan struct{}),
    }
}

// Start begins periodic clock synchronization.
func (cs *ClockSync) Start() error {
    if cs.running.Swap(true) {
        return nil // Already running
    }
    
    // Initial sync
    if err := cs.Sync(); err != nil {
        cs.running.Store(false)
        return err
    }
    
    // Start periodic sync
    go cs.syncLoop()
    
    log.Info().
        Str("exchange", cs.exchange).
        Dur("interval", cs.syncInterval).
        Msg("clock sync started")
    
    return nil
}

// Stop stops the clock synchronizer.
func (cs *ClockSync) Stop() {
    if !cs.running.Swap(false) {
        return
    }
    
    close(cs.stopCh)
    log.Info().Str("exchange", cs.exchange).Msg("clock sync stopped")
}

// Sync performs a single clock synchronization.
func (cs *ClockSync) Sync() error {
    if cs.timeProvider == nil {
        return errors.NewValidationError("timeProvider", nil, "must not be nil")
    }
    
    // Measure round-trip time
    localStart := time.Now().UnixMilli()
    serverTime, err := cs.timeProvider()
    if err != nil {
        return errors.NewConnectionError(cs.exchange, "clock", "sync failed", true, err)
    }
    localEnd := time.Now().UnixMilli()
    
    // Calculate offset (accounting for network latency)
    // Assume server time is at midpoint of round-trip
    localMid := (localStart + localEnd) / 2
    offset := serverTime - localMid
    
    cs.offset.Store(offset)
    cs.lastSync.Store(time.Now().UnixMilli())
    
    log.Debug().
        Str("exchange", cs.exchange).
        Int64("offset_ms", offset).
        Msg("clock synchronized")
    
    // Check if offset is acceptable
    if abs(offset) > cs.maxOffset.Milliseconds() {
        return errors.NewClockSyncError(
            cs.exchange,
            time.Duration(abs(offset))*time.Millisecond,
            cs.maxOffset,
        )
    }
    
    return nil
}

// syncLoop runs periodic synchronization.
func (cs *ClockSync) syncLoop() {
    ticker := time.NewTicker(cs.syncInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-cs.stopCh:
            return
        case <-ticker.C:
            if err := cs.Sync(); err != nil {
                log.Error().Err(err).Str("exchange", cs.exchange).Msg("clock sync failed")
            }
        }
    }
}

// Now returns the current synchronized time.
func (cs *ClockSync) Now() time.Time {
    offset := cs.offset.Load()
    return time.UnixMilli(time.Now().UnixMilli() + offset)
}

// UnixMilli returns the current synchronized time in milliseconds.
func (cs *ClockSync) UnixMilli() int64 {
    offset := cs.offset.Load()
    return time.Now().UnixMilli() + offset
}

// Offset returns the current clock offset.
func (cs *ClockSync) Offset() time.Duration {
    return time.Duration(cs.offset.Load()) * time.Millisecond
}

// IsSynchronized returns true if clock has been synchronized.
func (cs *ClockSync) IsSynchronized() bool {
    return cs.lastSync.Load() > 0
}

// LastSync returns the time of the last synchronization.
func (cs *ClockSync) LastSync() time.Time {
    return time.UnixMilli(cs.lastSync.Load())
}

// ValidateOffset checks if the current offset is within acceptable range.
func (cs *ClockSync) ValidateOffset() error {
    offset := abs(cs.offset.Load())
    maxMs := cs.maxOffset.Milliseconds()
    
    if offset > maxMs {
        return errors.NewClockSyncError(
            cs.exchange,
            time.Duration(offset)*time.Millisecond,
            cs.maxOffset,
        )
    }
    
    return nil
}

// SetTimeProvider sets the time provider function.
func (cs *ClockSync) SetTimeProvider(provider TimeProvider) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    cs.timeProvider = provider
}

// abs returns the absolute value of an int64.
func abs(n int64) int64 {
    if n < 0 {
        return -n
    }
    return n
}
```

Create internal/sync/nonce.go with nonce generation:

```go
package sync

import (
    "crypto/rand"
    "encoding/hex"
    "sync/atomic"
    "time"
)

// NonceGenerator generates unique nonces for replay protection.
type NonceGenerator struct {
    // Base timestamp to ensure uniqueness across restarts
    baseTime int64
    
    // Counter for multiple nonces within same millisecond
    counter atomic.Uint64
}

// NewNonceGenerator creates a new nonce generator.
func NewNonceGenerator() *NonceGenerator {
    return &NonceGenerator{
        baseTime: time.Now().UnixNano(),
    }
}

// Generate generates a unique nonce string.
// Format: <timestamp_ms>_<counter>_<random>
func (ng *NonceGenerator) Generate() string {
    timestamp := time.Now().UnixMilli()
    counter := ng.counter.Add(1)
    
    // Generate 4 bytes of randomness
    randomBytes := make([]byte, 4)
    rand.Read(randomBytes)
    random := hex.EncodeToString(randomBytes)
    
    return formatNonce(timestamp, counter, random)
}

// GenerateInt64 generates a unique nonce as int64.
// Uses timestamp + counter for guaranteed uniqueness.
func (ng *NonceGenerator) GenerateInt64() int64 {
    timestamp := time.Now().UnixMilli()
    counter := ng.counter.Add(1)
    
    // Combine timestamp (top bits) with counter (bottom bits)
    // Counter fits in 16 bits (max 65535 per millisecond)
    return (timestamp << 16) | int64(counter&0xFFFF)
}

// formatNonce formats the nonce components into a string.
func formatNonce(timestamp int64, counter uint64, random string) string {
    // Use a simple format that's URL-safe
    const digits = "0123456789abcdefghijklmnopqrstuvwxyz"
    
    buf := make([]byte, 0, 24)
    
    // Encode timestamp
    tmp := timestamp
    for tmp > 0 {
        buf = append(buf, digits[tmp%36])
        tmp /= 36
    }
    
    buf = append(buf, '_')
    
    // Encode counter (lower 16 bits)
    ctr := counter & 0xFFFF
    for ctr > 0 {
        buf = append(buf, digits[ctr%36])
        ctr /= 36
    }
    
    buf = append(buf, '_')
    
    // Append random
    buf = append(buf, random...)
    
    return string(buf)
}

// TimestampNonce generates a simple timestamp-based nonce.
// Suitable for Binance which uses timestamp in milliseconds.
func TimestampNonce() int64 {
    return time.Now().UnixMilli()
}
```

CRITICAL RULES:
- Clock offset MUST be < 500ms for Binance signed requests
- Sync periodically (every 5 minutes) to detect drift
- Account for network latency in offset calculation
- Nonces MUST be unique - use timestamp + counter + random
- TimeProvider injected from REST client
</action>
  <verify>
    go build ./internal/sync/...
    go vet ./internal/sync/...
  </verify>
  <done>
    internal/sync/clock.go exports ClockSync with Start/Stop/Now/Offset/ValidateOffset, internal/sync/nonce.go exports NonceGenerator with Generate/GenerateInt64
  </done>
</task>

<task type="auto">
  <name>Task 3: Create public Connector API</name>
  <files>
    pkg/connector/config.go
    pkg/connector/events.go
    pkg/connector/connector.go
  </files>
  <action>
Create pkg/connector/config.go with configuration types:

```go
// Package connector provides the public API for exchange connectivity.
package connector

import (
    "fmt"
    "time"
    
    "github.com/user/exchange-connector/pkg/errors"
)

// Config contains the main connector configuration.
type Config struct {
    // Exchange settings
    Exchange ExchangeConfig
    
    // Rate limiting
    RateLimit RateLimitConfig
    
    // Resilience
    CircuitBreaker CircuitBreakerConfig
    ClockSync      ClockSyncConfig
    
    // Connection
    Connection ConnectionConfig
}

// ExchangeConfig contains exchange-specific settings.
type ExchangeConfig struct {
    Name      string // Exchange name: "binance" or "bybit"
    APIKey    string // API key for authentication
    APISecret string // API secret for signing
    Testnet   bool   // Use testnet endpoints
}

// Validate validates exchange configuration.
func (c *ExchangeConfig) Validate() error {
    if c.Name == "" {
        return errors.NewValidationError("name", "", "must not be empty")
    }
    if c.Name != "binance" && c.Name != "bybit" {
        return errors.NewValidationError("name", c.Name, "must be 'binance' or 'bybit'")
    }
    // APIKey and APISecret can be empty for public-only access
    return nil
}

// RateLimitConfig contains rate limiting settings.
type RateLimitConfig struct {
    MaxWeight     int           // Maximum weight per interval (Binance: 1200)
    RequestDelay  time.Duration // Minimum delay between requests
    Enabled       bool          // Enable rate limiting (default: true)
}

// DefaultRateLimitConfig returns default rate limit configuration.
func DefaultRateLimitConfig() RateLimitConfig {
    return RateLimitConfig{
        MaxWeight:    1200,
        RequestDelay: 0,
        Enabled:      true,
    }
}

// CircuitBreakerConfig contains circuit breaker settings.
type CircuitBreakerConfig struct {
    MaxFailures      int           // Failures before opening
    SuccessThreshold int           // Successes to close from half-open
    OpenTimeout      time.Duration // Time before half-open
    Enabled          bool          // Enable circuit breaker (default: true)
}

// DefaultCircuitBreakerConfig returns default circuit breaker configuration.
func DefaultCircuitBreakerConfig() CircuitBreakerConfig {
    return CircuitBreakerConfig{
        MaxFailures:      5,
        SuccessThreshold: 3,
        OpenTimeout:      30 * time.Second,
        Enabled:          true,
    }
}

// ClockSyncConfig contains clock synchronization settings.
type ClockSyncConfig struct {
    MaxOffset    time.Duration // Maximum allowed offset
    SyncInterval time.Duration // How often to sync
    Enabled      bool          // Enable clock sync (default: true)
}

// DefaultClockSyncConfig returns default clock sync configuration.
func DefaultClockSyncConfig() ClockSyncConfig {
    return ClockSyncConfig{
        MaxOffset:    500 * time.Millisecond,
        SyncInterval: 5 * time.Minute,
        Enabled:      true,
    }
}

// ConnectionConfig contains connection settings.
type ConnectionConfig struct {
    Timeout          time.Duration // REST request timeout
    PingInterval     time.Duration // WebSocket ping interval
    ReconnectDelay   time.Duration // Initial reconnect delay
    MaxReconnectWait time.Duration // Maximum reconnect wait
}

// DefaultConnectionConfig returns default connection configuration.
func DefaultConnectionConfig() ConnectionConfig {
    return ConnectionConfig{
        Timeout:          10 * time.Second,
        PingInterval:     20 * time.Second,
        ReconnectDelay:   1 * time.Second,
        MaxReconnectWait: 60 * time.Second,
    }
}

// Builder provides a fluent interface for building Config.
type Builder struct {
    config Config
    errs   []error
}

// NewConfigBuilder creates a new configuration builder.
func NewConfigBuilder() *Builder {
    return &Builder{
        config: Config{
            RateLimit:      DefaultRateLimitConfig(),
            CircuitBreaker: DefaultCircuitBreakerConfig(),
            ClockSync:      DefaultClockSyncConfig(),
            Connection:     DefaultConnectionConfig(),
        },
    }
}

// Exchange sets exchange configuration.
func (b *Builder) Exchange(name, apiKey, apiSecret string, testnet bool) *Builder {
    b.config.Exchange = ExchangeConfig{
        Name:      name,
        APIKey:    apiKey,
        APISecret: apiSecret,
        Testnet:   testnet,
    }
    return b
}

// RateLimit sets rate limit configuration.
func (b *Builder) RateLimit(maxWeight int, delay time.Duration) *Builder {
    b.config.RateLimit = RateLimitConfig{
        MaxWeight:    maxWeight,
        RequestDelay: delay,
        Enabled:      true,
    }
    return b
}

// CircuitBreaker sets circuit breaker configuration.
func (b *Builder) CircuitBreaker(maxFailures int, timeout time.Duration) *Builder {
    b.config.CircuitBreaker = CircuitBreakerConfig{
        MaxFailures: maxFailures,
        OpenTimeout: timeout,
        Enabled:     true,
    }
    return b
}

// ClockSync sets clock sync configuration.
func (b *Builder) ClockSync(maxOffset, interval time.Duration) *Builder {
    b.config.ClockSync = ClockSyncConfig{
        MaxOffset:    maxOffset,
        SyncInterval: interval,
        Enabled:      true,
    }
    return b
}

// Timeout sets connection timeout.
func (b *Builder) Timeout(timeout time.Duration) *Builder {
    b.config.Connection.Timeout = timeout
    return b
}

// Build validates and returns the configuration.
func (b *Builder) Build() (Config, error) {
    if err := b.config.Exchange.Validate(); err != nil {
        b.errs = append(b.errs, err)
    }
    
    if len(b.errs) > 0 {
        return Config{}, fmt.Errorf("configuration errors: %v", b.errs)
    }
    
    // Return a copy
    return b.config, nil
}

// MustBuild validates and returns the configuration, panicking on error.
func (b *Builder) MustBuild() Config {
    cfg, err := b.Build()
    if err != nil {
        panic(err)
    }
    return cfg
}
```

Create pkg/connector/events.go with event types:

```go
package connector

import (
    "github.com/user/exchange-connector/pkg/domain"
)

// EventType represents the type of event.
type EventType string

const (
    EventTicker    EventType = "ticker"
    EventOrderBook EventType = "orderbook"
    EventTrade     EventType = "trade"
    EventOrder     EventType = "order"
    EventBalance   EventType = "balance"
)

// Event represents an event from the exchange.
type Event struct {
    Exchange string      // Exchange name
    Type     EventType   // Event type
    Data     interface{} // Event data (domain types)
}

// TickerHandler handles ticker events.
type TickerHandler func(exchange string, ticker *domain.Ticker)

// OrderBookHandler handles order book events.
type OrderBookHandler func(exchange string, orderbook *domain.OrderBook)

// TradeHandler handles trade events.
type TradeHandler func(exchange string, trade *domain.Trade)

// OrderHandler handles order update events.
type OrderHandler func(exchange string, order *domain.Order)

// ConnectionHandler handles connection state changes.
type ConnectionHandler func(exchange string, connected bool)

// ErrorHandler handles errors.
type ErrorHandler func(exchange string, err error)

// Handlers contains all event handlers.
type Handlers struct {
    OnTicker     TickerHandler
    OnOrderBook  OrderBookHandler
    OnTrade      TradeHandler
    OnOrder      OrderHandler
    OnConnect    ConnectionHandler
    OnDisconnect ConnectionHandler
    OnError      ErrorHandler
}
```

Create pkg/connector/connector.go with main Connector:

```go
package connector

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/rs/zerolog/log"
    
    "github.com/user/exchange-connector/internal/circuit"
    "github.com/user/exchange-connector/internal/driver/binance"
    "github.com/user/exchange-connector/internal/sync"
    "github.com/user/exchange-connector/pkg/domain"
    "github.com/user/exchange-connector/pkg/errors"
)

// Connector provides exchange connectivity with fault tolerance.
// One Connector instance connects to one exchange.
type Connector struct {
    config    Config
    exchange  string
    
    // Components
    restClient    *binance.RESTClient
    wsClient      *binance.WSClient
    circuitBreaker *circuit.Breaker
    clockSync     *sync.ClockSync
    nonceGen      *sync.NonceGenerator
    
    // State
    running    atomic.Bool
    ready      chan struct{}
    readyOnce  sync.Once
    
    // Handlers
    handlers Handlers
    
    // Lifecycle
    ctx    context.Context
    cancel context.CancelFunc
    wg     sync.WaitGroup
}

// New creates a new Connector for an exchange.
func New(cfg Config) (*Connector, error) {
    if err := cfg.Exchange.Validate(); err != nil {
        return nil, err
    }
    
    ctx, cancel := context.WithCancel(context.Background())
    
    c := &Connector{
        config:    cfg,
        exchange:  cfg.Exchange.Name,
        ready:     make(chan struct{}),
        nonceGen:  sync.NewNonceGenerator(),
        ctx:       ctx,
        cancel:    cancel,
    }
    
    // Initialize components
    if err := c.initComponents(); err != nil {
        cancel()
        return nil, err
    }
    
    return c, nil
}

// initComponents initializes all components.
func (c *Connector) initComponents() error {
    var err error
    
    // Create REST client
    restCfg := binance.Config{
        BaseURL:    "", // Use default or testnet based on config
        APIKey:     c.config.Exchange.APIKey,
        APISecret:  c.config.Exchange.APISecret,
        Timeout:    c.config.Connection.Timeout,
        MaxWeight:  c.config.RateLimit.MaxWeight,
        Testnet:    c.config.Exchange.Testnet,
    }
    
    c.restClient, err = binance.NewRESTClient(restCfg)
    if err != nil {
        return fmt.Errorf("failed to create REST client: %w", err)
    }
    
    // Create circuit breaker
    if c.config.CircuitBreaker.Enabled {
        c.circuitBreaker = circuit.NewBreaker(c.exchange, circuit.Config{
            MaxFailures:      c.config.CircuitBreaker.MaxFailures,
            SuccessThreshold: c.config.CircuitBreaker.SuccessThreshold,
            OpenTimeout:      c.config.CircuitBreaker.OpenTimeout,
        })
    }
    
    // Create clock sync
    if c.config.ClockSync.Enabled {
        c.clockSync = sync.NewClockSync(c.exchange, sync.ClockConfig{
            MaxOffset:    c.config.ClockSync.MaxOffset,
            SyncInterval: c.config.ClockSync.SyncInterval,
            TimeProvider: c.restClient.GetServerTime,
        })
    }
    
    // Create WebSocket client
    wsCfg := binance.WSConfig{
        Testnet:   c.config.Exchange.Testnet,
        PingInterval: c.config.Connection.PingInterval,
        Reconnect: binance.ReconnectConfig{
            InitialDelay: c.config.Connection.ReconnectDelay,
            MaxDelay:     c.config.Connection.MaxReconnectWait,
            MaxAttempts:  0, // Infinite
            Jitter:       0.1,
        },
    }
    
    c.wsClient = binance.NewWSClient(wsCfg)
    
    // Set up WebSocket handlers
    c.setupWSHandlers()
    
    return nil
}

// setupWSHandlers sets up WebSocket event handlers.
func (c *Connector) setupWSHandlers() {
    c.wsClient.OnTicker(func(ticker *domain.Ticker) {
        if c.handlers.OnTicker != nil {
            c.safeHandler(func() {
                c.handlers.OnTicker(c.exchange, ticker)
            })
        }
    })
    
    c.wsClient.OnOrderBook(func(ob *domain.OrderBook) {
        if c.handlers.OnOrderBook != nil {
            c.safeHandler(func() {
                c.handlers.OnOrderBook(c.exchange, ob)
            })
        }
    })
    
    c.wsClient.OnTrade(func(trade *domain.Trade) {
        if c.handlers.OnTrade != nil {
            c.safeHandler(func() {
                c.handlers.OnTrade(c.exchange, trade)
            })
        }
    })
    
    c.wsClient.OnConnect(func() {
        log.Info().Str("exchange", c.exchange).Msg("WebSocket connected")
        if c.handlers.OnConnect != nil {
            c.handlers.OnConnect(c.exchange, true)
        }
        c.markReady()
    })
    
    c.wsClient.OnDisconnect(func(err error) {
        log.Error().Err(err).Str("exchange", c.exchange).Msg("WebSocket disconnected")
        if c.handlers.OnDisconnect != nil {
            c.handlers.OnDisconnect(c.exchange, false)
        }
    })
}

// Start starts the connector.
// It returns immediately, use Ready() to wait for full initialization.
func (c *Connector) Start() error {
    if c.running.Swap(true) {
        return errors.New("connector already running")
    }
    
    log.Info().Str("exchange", c.exchange).Msg("starting connector")
    
    // Start clock sync (required for signed requests)
    if c.clockSync != nil {
        c.wg.Add(1)
        go func() {
            defer c.wg.Done()
            if err := c.clockSync.Start(); err != nil {
                log.Error().Err(err).Msg("clock sync failed")
                if c.handlers.OnError != nil {
                    c.handlers.OnError(c.exchange, err)
                }
            }
        }()
    }
    
    // Connect WebSocket
    c.wg.Add(1)
    go func() {
        defer c.wg.Done()
        if err := c.wsClient.Connect(); err != nil {
            log.Error().Err(err).Msg("WebSocket connection failed")
            if c.handlers.OnError != nil {
                c.handlers.OnError(c.exchange, err)
            }
        }
    }()
    
    // For simple cases without subscriptions, mark ready immediately
    // WebSocket will mark ready when it connects
    
    return nil
}

// Stop stops the connector gracefully.
func (c *Connector) Stop() error {
    if !c.running.Swap(false) {
        return nil // Not running
    }
    
    log.Info().Str("exchange", c.exchange).Msg("stopping connector")
    
    // Cancel context
    c.cancel()
    
    // Stop components
    if c.clockSync != nil {
        c.clockSync.Stop()
    }
    
    if c.wsClient != nil {
        c.wsClient.Close()
    }
    
    // Wait for goroutines
    done := make(chan struct{})
    go func() {
        c.wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
    case <-time.After(30 * time.Second):
        log.Warn().Msg("timeout waiting for goroutines to stop")
    }
    
    // Close REST client
    if c.restClient != nil {
        c.restClient.Close()
    }
    
    log.Info().Str("exchange", c.exchange).Msg("connector stopped")
    
    return nil
}

// Ready returns a channel that is closed when the connector is ready.
func (c *Connector) Ready() <-chan struct{} {
    return c.ready
}

// markReady marks the connector as ready.
func (c *Connector) markReady() {
    c.readyOnce.Do(func() {
        close(c.ready)
    })
}

// IsRunning returns true if the connector is running.
func (c *Connector) IsRunning() bool {
    return c.running.Load()
}

// IsConnected returns true if WebSocket is connected.
func (c *Connector) IsConnected() bool {
    return c.wsClient != nil && c.wsClient.IsConnected()
}

// Exchange returns the exchange name.
func (c *Connector) Exchange() string {
    return c.exchange
}

// SetHandlers sets event handlers.
func (c *Connector) SetHandlers(handlers Handlers) {
    c.handlers = handlers
}

// SubscribeTicker subscribes to ticker updates for a symbol.
// Returns an unsubscribe function.
func (c *Connector) SubscribeTicker(symbol string) (func(), error) {
    if !c.running.Load() {
        return nil, errors.New("connector not running")
    }
    
    stream := binance.NewStreamBuilder(symbol).Ticker()
    if err := c.wsClient.Subscribe(stream); err != nil {
        return nil, err
    }
    
    return func() {
        c.wsClient.Unsubscribe(stream)
    }, nil
}

// SubscribeOrderBook subscribes to order book updates for a symbol.
func (c *Connector) SubscribeOrderBook(symbol string) (func(), error) {
    if !c.running.Load() {
        return nil, errors.New("connector not running")
    }
    
    stream := binance.NewStreamBuilder(symbol).Depth()
    if err := c.wsClient.Subscribe(stream); err != nil {
        return nil, err
    }
    
    return func() {
        c.wsClient.Unsubscribe(stream)
    }, nil
}

// SubscribeTrades subscribes to trade updates for a symbol.
func (c *Connector) SubscribeTrades(symbol string) (func(), error) {
    if !c.running.Load() {
        return nil, errors.New("connector not running")
    }
    
    stream := binance.NewStreamBuilder(symbol).Trade()
    if err := c.wsClient.Subscribe(stream); err != nil {
        return nil, err
    }
    
    return func() {
        c.wsClient.Unsubscribe(stream)
    }, nil
}

// Ping tests REST connectivity.
func (c *Connector) Ping(ctx context.Context) error {
    if c.circuitBreaker != nil {
        return c.circuitBreaker.Execute(func() error {
            return c.restClient.Ping(ctx)
        })
    }
    return c.restClient.Ping(ctx)
}

// GetServerTime retrieves the exchange server time.
func (c *Connector) GetServerTime(ctx context.Context) (int64, error) {
    if c.circuitBreaker != nil {
        result, err := c.circuitBreaker.ExecuteWithResult(func() (interface{}, error) {
            return c.restClient.GetServerTime(ctx)
        })
        if err != nil {
            return 0, err
        }
        return result.(int64), nil
    }
    return c.restClient.GetServerTime(ctx)
}

// GetExchangeInfo retrieves exchange trading rules.
func (c *Connector) GetExchangeInfo(ctx context.Context) (*binance.ExchangeInfo, error) {
    if c.circuitBreaker != nil {
        result, err := c.circuitBreaker.ExecuteWithResult(func() (interface{}, error) {
            return c.restClient.GetExchangeInfo(ctx)
        })
        if err != nil {
            return nil, err
        }
        return result.(*binance.ExchangeInfo), nil
    }
    return c.restClient.GetExchangeInfo(ctx)
}

// CircuitBreakerStats returns circuit breaker statistics.
func (c *Connector) CircuitBreakerStats() (circuit.Stats, error) {
    if c.circuitBreaker == nil {
        return circuit.Stats{}, errors.New("circuit breaker not enabled")
    }
    return c.circuitBreaker.Stats(), nil
}

// ClockOffset returns the current clock offset.
func (c *Connector) ClockOffset() time.Duration {
    if c.clockSync == nil {
        return 0
    }
    return c.clockSync.Offset()
}

// safeHandler executes a handler with panic recovery.
func (c *Connector) safeHandler(fn func()) {
    defer func() {
        if r := recover(); r != nil {
            log.Error().Interface("panic", r).Str("exchange", c.exchange).Msg("handler panic recovered")
        }
    }()
    fn()
}
```

CRITICAL RULES:
- One Connector = one exchange (per-exchange isolation)
- Start() is async - use Ready() to wait for full initialization
- Stop() must be graceful (wait for goroutines, close resources)
- All callbacks MUST be wrapped in panic recovery
- Circuit breaker wraps all REST calls
- Clock sync must be started before signed requests
- Return unsubscribe function from subscribe methods
</action>
  <verify>
    go build ./pkg/connector/...
    go vet ./pkg/connector/...
    
    # Verify public API
    grep -n "func.*Connector" pkg/connector/connector.go | head -10
  </verify>
  <done>
    pkg/connector/config.go exports Config/Builder, pkg/connector/events.go exports event handlers, pkg/connector/connector.go exports Connector with Start/Stop/Subscribe methods
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all packages build:
   ```bash
   go build ./internal/circuit/...
   go build ./internal/sync/...
   go build ./pkg/connector/...
   go vet ./...
   ```

2. Verify public API exports:
   ```bash
   grep -E "^func.*\(.*\*Connector\)" pkg/connector/connector.go
   ```

3. Verify circuit breaker has three states:
   ```bash
   grep -n "StateClosed\|StateHalfOpen\|StateOpen" internal/circuit/breaker.go
   ```

4. Verify clock sync validation:
   ```bash
   grep -n "ValidateOffset\|maxOffset" internal/sync/clock.go
   ```
</verification>

<success_criteria>
- internal/circuit/breaker.go exports Breaker with Execute/State methods
- internal/sync/clock.go exports ClockSync with Start/Stop/Now/ValidateOffset
- internal/sync/nonce.go exports NonceGenerator with Generate
- pkg/connector/config.go exports Config with fluent Builder
- pkg/connector/connector.go exports Connector with Start/Stop/Subscribe
- Circuit breaker wraps all REST calls
- Clock sync maintains <500ms offset
- All code compiles without errors
- Public API is clean and well-documented
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-binance/01-04-SUMMARY.md`
</output>
